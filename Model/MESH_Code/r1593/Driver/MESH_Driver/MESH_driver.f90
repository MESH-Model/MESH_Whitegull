program RUNMESH

!>       MESH DRIVER
!>
!>       NOV 2015 - DGP. Moved incrementing the counters to
!>                  after routing has finished. This impacts when daily
!>                  and cumulative daily streamflow are written to file
!>                  and screen. The average daily streamflow was
!>                  calculated between 23:00-23:30 before the fix, tied
!>                  to an if statement about NCOUNT == 48, which
!>                  occurred shortly after NCOUNT = NCOUNT + 1 in the
!>                  same time-step. Average daily streamflow is
!>                  calculated between 23:30-24:00 after the fix. The
!>                  change causes results in MESH_output_streamflow.csv
!>                  and MESH_output_streamflow_cumulative.csv to differ
!>                  by the amount of flow calculated between
!>                  23:30-24:00. Metrics calculated based on streamflow
!>                  also change. The daily runoff generated by CLASS
!>                  remains unchanged.
!>                  Because metrics and streamflow results differ
!>                  between this and prior revisions, r909 might be
!>                  considered the start of MESH 1.4.
!>
!>       JAN 2013 - K.C.KORNELSEN
!>                - INCORPORATED LOCATION FLAG FOR INCREASING PRECISION
!>                - OF STREAMFLOW AND RESERVOIR INPUTS
!>                - INCLUDED NSE AND NEGATIVE NSE AS OBJFN'S
!>       JAN 2014 - M. MACDONALD.  INCORPORATED BLOWING SNOW ALGORITHMS
!>       AUG 2013 - M. MACDONALD
!>                - INCORPORATE OPTIONAL COUPLING OF CLASS WITH CTEM
!>                - MOVE SOME INITIALIZATION AND SCATTER OF CLASS
!>                  DIAGNOSTIC VARIABLES IN TO MESH_DRIVER
!>       JUN 2010 - F. SEGLENIEKS. 
!>                - ADDED CODE TO HAVE MESH ONLY RUN ON BASINS LISTED IN 
!>                  THE STREAMFLOW FILE, CALLED THE SUBBASIN FEATURE
!>       JUN 2010 - M.A.MEKONNEN/B.DAVIDSON/M.MacDONALD. 
!>                - BUG FIX FOR READING FORCING DATA IN CSV FORMAT 
!>                  WITH 1 HOUR INTERVAL
!>                - READING FORCING DATA WITH VARIOUS TIME STEPS
!>                - FORCING DATA INTERPOLATION TO 30 MINUTE INTERVALS
!>                  (CLASS MODEL TIME STEP)
!>                - PRE-EMPTION OPTION FOR AUTOCALIBRATION
!>                - CHECKING FOR PARAMETER MINIMUM AND MAXIMUM LIMITS
!>                - PATH SPECIFICATION THAT WORKS FOR BOTH WINDOWS AND 
!>                  UNIX SYSTEMS
!>
!>       AUG 2009 - B.DAVISON. CHANGES TO UPDATE TO SA_MESH 1.3
!>       APL 2009 - CLEAN COMMENTS AND REFINE STRUCTURE AFTER CODE REVIEW
!>       FEB 2009 - MESH12-01 BUG FIX AND ADDING NEW FEATURES
!>       AUG 28/07 - F.SEGLENIEKS. CHANGED FILENAMES AND REARRANGED THE CODE
!>       MAY 21/07 - B.DAVISON.    INITIAL VERSION BASED ON WORK OF E.D. SOULIS
!>       AND F. SEGLENIEKS AT THE UNIVERSITY OF WATERLOO
!>
!>=======================================================================
!>       DIMENSION STATEMENTS.
!>
!>       FIRST SET OF DEFINITIONS:
!>       BACKGROUND VARIABLES, AND PROGNOSTIC AND DIAGNOSTIC
!>       VARIABLES NORMALLY PROVIDED BY AND/OR USED BY THE GCM.
!>       THE SUFFIX "ROW" REFERS TO VARIABLES EXISTING ON THE
!>       MOSAIC GRID ON THE CURRENT LATITUDE CIRCLE.  THE SUFFIX
!>       "GAT" REFERS TO THE SAME VARIABLES AFTER THEY HAVE UNDERGONE
!>       A "GATHER" OPERATION IN WHICH THE TWO MOSAIC DIMENSIONS
!>       ARE COLLAPSED INTO ONE.  THE SUFFIX "GRD" REFERS BOTH TO
!>       GRID-CONSTANT INPUT VARIABLES. AND TO GRID-AVERAGED
!>       DIAGNOSTIC VARIABLES.
!>
!>       THE FIRST DIMENSION ELEMENT OF THE "ROW" VARIABLES
!>       REFERS TO THE NUMBER OF GRID CELLS ON THE CURRENT
!>       LATITUDE CIRCLE.  IN THIS STAND-ALONE VERSION, THIS
!>       NUMBER IS ARBITRARILY SET TO THREE, TO ALLOW UP TO THREE
!>       SIMULTANEOUS TESTS TO BE RUN.  THE SECOND DIMENSION
!>       ELEMENT OF THE "ROW" VARIABLES REFERS TO THE MAXIMUM
!>       NUMBER OF TILES IN THE MOSAIC.  IN THIS STAND-ALONE
!>       VERSION, THIS NUMBER IS SET TO EIGHT.  THE FIRST
!>       DIMENSION ELEMENT IN THE "GAT" VARIABLES IS GIVEN BY
!>       THE PRODUCT OF THE FIRST TWO DIMENSION ELEMENTS IN THE
!>       "ROW" VARIABLES.

!> Note, the internal comments are to be organised with 
!> the following symbols:
!>  -the symbols "!>" at the beginning of the line means that the 
!>  following comments are descriptive documentation.
!>  -the symbols "!*" means that the following comment is a variable
!>  definition.
!>  -the symbols "!+" means that the following comment contains code 
!>  that may be useful in the future and should not be deleted.
!>  -the symbols "!-" means that the following comment contains code
!>  that is basically garbage, and can be deleted safely at any time.
!>  -the symbol "!" or any number of exclamation marks can be used
!>  by the developers for various temporary code commenting.
!>  -the symbol "!todo" refers to places where the developers would 
!>  like to work on.
!>  -the symbol "!futuredo" refers to places where the developers
!>  would like to work on with a low priority.

    use mpi_module
    use model_files
    use sa_mesh_common
    use FLAGS
    use sa_mesh_run_within_tile
    use sa_mesh_run_within_grid
    use sa_mesh_run_between_grid
    use model_dates
    use climate_forcing
    use output_files
    use save_basin_output
    use SIMSTATS

    implicit none

    !> Constants.
    !*  RELEASE: MESH family/program release.
    !*  VERSION: MESH_DRIVER version.
    character(len = DEFAULT_FIELD_LENGTH), parameter :: RELEASE = '1.4'
    character(len = DEFAULT_FIELD_LENGTH), parameter :: VERSION = '1593'

    !> Local variables.
    character(len = DEFAULT_LINE_LENGTH) RELEASE_STRING

    !* ierr: Diagnostic error/status return from various subroutines.
    integer :: ierr = 0

    !> Local variables.
    !* NA: Temporary store for the number of grid cells.
    !* NTYPE: Temporary store for the number of GRUs.
    !* NML: Temporary store for the number of active land elements (NA, NTYPE).
    !* NSL: Temporary store for the number of soil layers.
    !* iun: Temporary store for the unit number of a file.
    integer NA, NTYPE, NML, NSL, iun, ignd

!todo: clean up comments and arrange variables a bit better

!> START ENSIM == FOR ENSIM == FOR ENSIM == FOR ENSIM ==
    integer(kind = 4) ensim_month, ensim_day
    integer(kind = 4) WFO_SEQ
!> == ENSIM == ENSIM == ENSIM == ENSIM == ENSIM ==

    integer i, j, k, l, m, u, z
    character(len = DEFAULT_LINE_LENGTH) line

    integer FRAME_NO_NEW

    !> Logicals to control simulation runs.
    !*  ENDDATE: Signals reached simulation end date.
    !*  ENDDATA: Signals reached end of forcing data.
    logical ENDDATE, ENDDATA

    type(fl_ids) fls
    type(ShedGridParams) shd
    type(CLIM_INFO) cm

    !> Basin totals for the run from RESUMEFLAG.
    real TOTAL_PRE, TOTAL_EVAP, TOTAL_ROF, STG_INI, STG_FIN, TOTAL_ROFO, TOTAL_ROFS, TOTAL_ROFB

    !> End of run states for prognostic variables.
    real, dimension(:, :), allocatable :: tcan, rcan, sncan, gro, zpnd, tpnd, sno, tsno, albs, rhos
    real, dimension(:, :, :), allocatable :: tbar, thlq, thic
    integer, dimension(:), allocatable :: kc
    character cfmt*3, cfmtt*1000

    logical R2COUTPUT
    integer, parameter :: R2CFILEUNITSTART = 500
    integer NR2C, DELTR2C, NR2CFILES, NR2CSTATES, NR2C_R, DELTR2C_R, NR2C_S, DELTR2C_S
    integer, allocatable, dimension(:) :: GRD, GAT, GRDGAT, GRD_R, GAT_R, GRDGAT_R, GRD_S, GAT_S, GRDGAT_S
    character(50), allocatable, dimension(:, :) :: R2C_ATTRIBUTES, R2C_ATTRIBUTES_R, R2C_ATTRIBUTES_S

    real startprog, endprog

    !> For reading arguments from the command line.
    character(500) fl_listMesh
    integer narg
    logical ltest

    !> Set program start time.
!todo: Also set date, which can be used for EnSim outputs.
    call cpu_time(startprog)

    !> Reset spacing for screen output.
    call reset_tab()

    !> Initialize MPI.
    call MPI_Init(ierr)
    if (ierr /= MPI_SUCCESS) then
        call print_warning('Failed to initialize MPI.')
        write(line, FMT_GEN) ierr
        call print_message_detail('Error status: ' // trim(adjustl(line)))
        call program_abort()
    end if

    !> Grab number of total processes and current process ID.
    call MPI_Comm_size(mpi_comm_world, inp, z)
    call MPI_Comm_rank(mpi_comm_world, ipid, z)

    !> izero is active if the head node is used for booking and lateral flow
    !> processes.
    if (inp > 1) then
        izero = 1
    else
        izero = 0
    end if

    !> Reset verbose flag for worker nodes.
    if (ipid > 0) ISHEADNODE = .false.

    !> Write MESH version to screen.
    write(RELEASE_STRING, "('MESH ', (a), ' ---  (', (a), ')')") trim(RELEASE), trim(VERSION)
    call print_screen(RELEASE_STRING)
    call print_screen('')

    !> Check if any command line arguments are found.
    narg = command_argument_count()
    if (narg > 0) then

        !> File handled for variable in/out names
        !> At the moment only class, hydro parameters and some outputs
        if (narg >= 1) then
            call get_command_argument(1, fl_listMesh)
        end if
        call Init_fls(fls, trim(adjustl(fl_listMesh)))
    else
!todo: Call this anyway, make loading values from file an alternate subroutine of module_files
        call Init_fls(fls)
    end if !(narg > 0) then

    !> Read inputs.
    ierr = 0
    call READ_INITIAL_INPUTS(fls, shd, cm, RELEASE_STRING, ierr)

    !> Stop if an error occured.
    call reset_tab()
    call MPI_Barrier(MPI_COMM_WORLD, z)
    if (ierr /= 0) then
        call print_error('Errors occurred during initialization.')
        if (ISHEADNODE) call program_abort()
    else
        call print_message('')
    end if

    !> Assign shed values to local variables.
!    NA = shd%NA
!    NTYPE = shd%lc%NTYPE
!    NSL = shd%lc%IGND
!    NML = shd%lc%NML

    !> Initialize climate forcing module.
    if (ro%RUNCLIM) then
        ENDDATA = climate_module_init(fls, shd, il1, il2, cm)
        if (ENDDATA) goto 97
    end if
    call print_message('')

    !> Initialize output variables.
    call output_variables_init(shd)

    !> Allocate output variables for screen output.
    if (PRINTSIMSTATUS == OUT_JDATE_DLY .or. PRINTSIMSTATUS == OUT_DATE_DLY) then
        call output_variables_activate(out%d%grid, (/ VN_PREC, VN_EVAP, VN_ROF /))
    end if
    call output_variables_activate(out%d%grid, VN_QO)
    if (PRINTSIMSTATUS == OUT_JDATE_MLY .or. PRINTSIMSTATUS == OUT_DATE_MLY) then
        call output_variables_activate(out%m%grid, (/ VN_PREC, VN_EVAP, VN_ROF, VN_QO /))
    end if

    !> Allocate output variables for run totals.
    call output_variables_activate( &
        out%tot%grid, (/ &
            VN_PREC, VN_EVAP, VN_ROF, VN_ROFO, VN_ROFS, VN_ROFB, &
            VN_RCAN, VN_SNCAN, VN_SNO, VN_WSNO, VN_PNDW, VN_LZS, VN_DZS, VN_LQWS, VN_FZWS /))

    !> Initialize process modules.
    if (ro%RUNTILE) then
        call run_within_tile_init(fls, shd, cm)
        call run_within_grid_init(fls, shd, cm)
    end if
    if (ro%RUNGRID) call run_between_grid_init(fls, shd, cm)
    call print_message('')

    !> Initialize basin totals for the run.
    if (ISHEADNODE) then
        TOTAL_PRE = 0.0
        TOTAL_EVAP = 0.0
        TOTAL_ROF = 0.0
        TOTAL_ROFO = 0.0
        TOTAL_ROFS = 0.0
        TOTAL_ROFB = 0.0
    end if

    !> Open output files.
    if (ISHEADNODE) then
        call output_files_init(fls, shd)
        call run_save_basin_output_init(fls, shd, cm)
    end if

    FRAME_NO_NEW = 1

    if (ISHEADNODE) then

    !> ******************************************************
    !> echo print information to MESH_output_echo_print.txt
    !> ******************************************************

        if (ECHOTXTMODE) then
            write(ECHO_TXT_IUN, *)
            write(ECHO_TXT_IUN, "('MESH_input_run_options.ini')")
            write(ECHO_TXT_IUN, *)
            write(ECHO_TXT_IUN, "('Configuration flags - specified by user or default values')")

!todo: this list should be updated (dgp: 2015-01-09)
            write(ECHO_TXT_IUN, *) 'BASINSHORTWAVEFLAG   = ', cm%dat(ck%FB)%ffmt
            write(ECHO_TXT_IUN, *) 'BASINLONGWAVEFLAG    = ', cm%dat(ck%FI)%ffmt
            write(ECHO_TXT_IUN, *) 'BASINRAINFLAG        = ', cm%dat(ck%RT)%ffmt
            write(ECHO_TXT_IUN, *) 'BASINTEMPERATUREFLAG = ', cm%dat(ck%TT)%ffmt
            write(ECHO_TXT_IUN, *) 'BASINWINDFLAG        = ', cm%dat(ck%UV)%ffmt
            write(ECHO_TXT_IUN, *) 'BASINPRESFLAG        = ', cm%dat(ck%P0)%ffmt
            write(ECHO_TXT_IUN, *) 'BASINHUMIDITYFLAG    = ', cm%dat(ck%HU)%ffmt
            write(ECHO_TXT_IUN, *) 'RESUMEFLAG           = ', RESUMEFLAG
            write(ECHO_TXT_IUN, *) 'SAVERESUMEFLAG       = ', SAVERESUMEFLAG
            write(ECHO_TXT_IUN, *) 'SHDFILEFLAG          = ', SHDFILEFMT
            write(ECHO_TXT_IUN, *) 'SOILINIFLAG          = ', SOILINIFLAG
            write(ECHO_TXT_IUN, *) 'PREEMPTIONFLAG       = ', mtsflg%PREEMPTIONFLAG
            write(ECHO_TXT_IUN, *) 'SUBBASINFLAG         = ', SUBBASINFLAG
            write(ECHO_TXT_IUN, *) 'R2COUTPUTFLAG        = ', R2COUTPUTFLAG
            write(ECHO_TXT_IUN, *) 'OBJFNFLAG            = ', OBJFNFLAG
            write(ECHO_TXT_IUN, *) 'AUTOCALIBRATIONFLAG  = ', mtsflg%AUTOCALIBRATIONFLAG
            write(ECHO_TXT_IUN, *) 'WINDOWSIZEFLAG       = ', WINDOWSIZEFLAG
            write(ECHO_TXT_IUN, *) 'WINDOWSPACINGFLAG    = ', WINDOWSPACINGFLAG
            write(ECHO_TXT_IUN, *) 'FROZENSOILINFILFLAG  = ', FROZENSOILINFILFLAG

!todo: restore this.
!            write(ECHO_TXT_IUN, *)
!            write(ECHO_TXT_IUN, "('MESH_parameters_hydrology.ini')")
!            write(ECHO_TXT_IUN, *)
!            write(ECHO_TXT_IUN, "('River roughnesses:')")
!todo: change this to use NRVR.
!            write(ECHO_TXT_IUN, '(5f6.3)') (WF_R2(i), i = 1, 5)
!            write(ECHO_TXT_IUN, "('Land class independent hydrologic parameters:')")
!            if (FROZENSOILINFILFLAG == 1) then
!                write(ECHO_TXT_IUN, *) 'SOIL_POR_MAX = ', SOIL_POR_MAX
!                write(ECHO_TXT_IUN, *) 'SOIL_DEPTH   = ', SOIL_DEPTH
!                write(ECHO_TXT_IUN, *) 'S0           = ', S0
!                write(ECHO_TXT_IUN, *) 'T_ICE_LENS   = ', T_ICE_LENS
!                do i = 5, INDEPPAR
!                    j = i - 4
!                    write(ECHO_TXT_IUN, '(a38, i2, a3, f6.2)') 'OPPORTUNITY TIME FOR SIMULATION YEAR ', j, ' = ', t0_ACC(j)
!                end do
!            else
!                do i = 1, INDEPPAR
!                    write(ECHO_TXT_IUN, '(a36, i2, a19)') 'FROZEN SOIL INFILTRATION PARAMETER ', i, ' READ BUT NOT USED'
!                end do
!            end if !(FROZENSOILINFILFLAG == 1) then
!            write(ECHO_TXT_IUN, "('Land class dependent hydrologic parameters:')")
!            write(NMTESTFORMAT, "(a10, i3, 'f10.2)')") "('ZSNLROW'", shd%lc%NTYPE
!            write(ECHO_TXT_IUN, NMTESTFORMAT) (hp%ZSNLROW(1, m), m = 1, shd%lc%NTYPE)
!            write(NMTESTFORMAT, "(a10, i3, 'f10.2)')") "('ZPLSROW'", shd%lc%NTYPE
!            write(ECHO_TXT_IUN, NMTESTFORMAT) (hp%ZPLSROW(1, m), m = 1, shd%lc%NTYPE)
!            write(NMTESTFORMAT, "(a10, i3, 'f10.2)')") "('ZPLGROW'", shd%lc%NTYPE
!            write(ECHO_TXT_IUN, NMTESTFORMAT) (hp%ZPLGROW(1, m), m = 1, shd%lc%NTYPE)
!            if (DEPPAR >= 4) then
!                write(NMTESTFORMAT, "(a10, i3, 'f10.2)')") "('FRZCROW'", shd%lc%NTYPE
!                write(ECHO_TXT_IUN, NMTESTFORMAT) (hp%FRZCROW(1, m), m = 1, shd%lc%NTYPE)
!            end if
!            write(ECHO_TXT_IUN, *)
!            write(ECHO_TXT_IUN, "('MESH_parameters_CLASS.ini')")
!            write(ECHO_TXT_IUN, *)
!            write(ECHO_TXT_IUN, '(2x, 6a4)') TITLE1, TITLE2, TITLE3, TITLE4, TITLE5, TITLE6
!            write(ECHO_TXT_IUN, '(2x, 6a4)') NAME1, NAME2, NAME3, NAME4, NAME5, NAME6
!            write(ECHO_TXT_IUN, '(2x, 6a4)') PLACE1, PLACE2, PLACE3, PLACE4, PLACE5, PLACE6
!            i = 1
!            write(ECHO_TXT_IUN, '(5f10.2, f7.1, 3i5)') &
!                DEGLAT, DEGLON, cp%ZRFMGRD(i), cp%ZRFHGRD(i), cp%ZBLDGRD(i), cp%GCGRD(i), shd%wc%ILG, shd%NA, shd%lc%NTYPE
!            do m = 1, shd%lc%NTYPE
!                write(ECHO_TXT_IUN, '(9f8.3)') (cp%FCANROW(i, m, j), j = 1, ICAN + 1), (cp%PAMXROW(i, m, j), j = 1, ICAN)
!                write(ECHO_TXT_IUN, '(9f8.3)') (cp%LNZ0ROW(i, m, j), j = 1, ICAN + 1), (cp%PAMNROW(i, m, j), j = 1, ICAN)
!                write(ECHO_TXT_IUN, '(9f8.3)') (cp%ALVCROW(i, m, j), j = 1, ICAN + 1), (cp%CMASROW(i, m, j), j = 1, ICAN)
!                write(ECHO_TXT_IUN, '(9f8.3)') (cp%ALICROW(i, m, j), j = 1, ICAN + 1), (cp%ROOTROW(i, m, j), j = 1, ICAN)
!                write(ECHO_TXT_IUN, '(4f8.3, 8x, 4f8.3)') (cp%RSMNROW(i, m, j), j = 1, ICAN), (cp%QA50ROW(i, m, j), j = 1, ICAN)
!                write(ECHO_TXT_IUN, '(4f8.3, 8x, 4f8.3)') (cp%VPDAROW(i, m, j), j = 1, ICAN), (cp%VPDBROW(i, m, j), j = 1, ICAN)
!                write(ECHO_TXT_IUN, '(4f8.3, 8x, 4f8.3)') (cp%PSGAROW(i, m, j), j = 1, ICAN), (cp%PSGBROW(i, m, j), j = 1, ICAN)
!                write(ECHO_TXT_IUN, '(3f8.3, f8.4)') cp%DRNROW(i, m), cp%SDEPROW(i, m), cp%FAREROW(i, m), cp%DDROW(i, m)
!                write(ECHO_TXT_IUN, '(4e8.1, i8)') cp%XSLPROW(i, m), cp%XDROW(i, m), cp%MANNROW(i, m), cp%KSROW(i, m), cp%MIDROW(i, m)
!                write(ECHO_TXT_IUN, '(6f10.1)') (cp%SANDROW(i, m, j), j = 1, shd%lc%IGND)
!                write(ECHO_TXT_IUN, '(6f10.1)') (cp%CLAYROW(i, m, j), j = 1, shd%lc%IGND)
!                write(ECHO_TXT_IUN, '(6f10.1)') (cp%ORGMROW(i, m, j), j = 1, shd%lc%IGND)
!                write(ECHO_TXT_IUN, '(9f10.2)') (cp%TBARROW(i, m, j), j = 1, shd%lc%IGND), cp%TCANROW(i, m), cp%TSNOROW(i, m), cp%TPNDROW(i, m)
!                write(ECHO_TXT_IUN, '(10f10.3)') &
!                    (cp%THLQROW(i, m, j), j = 1, shd%lc%IGND), (cp%THICROW(i, m, j), j = 1, shd%lc%IGND), cp%ZPNDROW(i, m)
!                write(ECHO_TXT_IUN, '(2f10.4, f10.2, f10.3, f10.4, f10.3, f10.3)') &
!                    cp%RCANROW(i, m), cp%SCANROW(i, m), cp%SNOROW(i, m), cp%ALBSROW(i, m), cp%RHOSROW(i, m), cp%GROROW(i, m)
!                write(ECHO_TXT_IUN, *)
!            end do !m = 1, shd%lc%NTYPE
        end if
    end if

    !> Open and print header information to the output files
    !> Open and read in values from r2c_output.txt file
    if (ISHEADNODE) then
        NR2CFILES = 0
        if (R2COUTPUTFLAG >= 1) then
            inquire(file = 'r2c_output.txt', exist = R2COUTPUT)
            if (R2COUTPUT) then
                open(56, file = 'r2c_output.txt', action = 'read')
                read(56, *, iostat = ierr) NR2C, DELTR2C
                if (ierr == 0) then
                    allocate(GRD(NR2C), GAT(NR2C), GRDGAT(NR2C), R2C_ATTRIBUTES(NR2C, 3), stat = ierr)
                    if (ierr /= 0) then
                        call print_error('Unable to allocate variables for R2C output.')
                        call print_message('Check the value of the first record at the first line in r2c_output.txt.')
                        call print_message('The value should be an integer value greater than zero.')
                        call program_abort()
                    end if
                end if
                if (ierr /= 0 .or. mod(DELTR2C, 30) /= 0) then
                    call print_error('Configuration error in r2c_output.txt')
                    call print_message('The first record at the first line is the number of variables.')
                    call print_message('The second record at the first line is the time-step for output.')
                    call print_message('The time-step should be a multiple of 30.')
                    call program_abort()
                end if
                call print_echo_txt('')
                call print_echo_txt('r2c output will be written for the following fields:')
                do i = 1, NR2C
                    read(56, *, iostat = ierr) GRD(i), GAT(i), GRDGAT(i), (R2C_ATTRIBUTES(i, j), j = 1, 3)
                    if (ierr /= 0) then
                        write(line, FMT_GEN) i + 1
                        call print_error('Error reading record: ' // trim(line))
                        call print_message('The first 3 columns should contain values of 0 or 1.')
                        call print_message('The last 3 columns should contain information about the variable.')
                        call program_abort()
                    else
                        if (GRD(i) == 1) then
                            NR2CFILES = NR2CFILES + 1
                            write(line, "(i3, ' (GRD)    : ', (a))") NR2CFILES, R2C_ATTRIBUTES(i, 3)
                            call print_echo_txt(line)
                        end if
                        if (GAT(i) == 1) then
                            NR2CFILES = NR2CFILES + 1
                            write(line, "(i3, ' (GRD)    : ', (a))") NR2CFILES, R2C_ATTRIBUTES(i, 3)
                            call print_echo_txt(line)
                        end if
                        if (GRDGAT(i) == 1) then
                            NR2CFILES = NR2CFILES + 1
                            write(line, "(i3, ' (GRDGAT) : ', (a))") NR2CFILES, R2C_ATTRIBUTES(i, 3)
                            call print_echo_txt(line)
                        end if
                    end if
                end do
                close(56)
            else
                call print_error('Unable to open: r2c_output.txt')
                call print_message('Check that the file exists or set R2COUTPUTFLAG to zero.')
                call program_abort()
            end if
        end if

        !> WRITE THE HEADER FOR R2C FILES:
        if (NR2CFILES > 0) then
            call WRITE_R2C_HEADER(shd%lc%NTYPE, NR2C, NR2CFILES, GRD, GAT, GRDGAT, R2C_ATTRIBUTES, &
                                  R2CFILEUNITSTART, NR2CSTATES, shd%CoordSys%Proj, shd%CoordSys%Ellips, shd%CoordSys%Zone, &
                                  shd%xOrigin, shd%yOrigin, shd%xDelta, shd%yDelta, shd%xCount, shd%yCount)
        end if

        !> For the ENSIM timestamp
        wfo_seq = 0

    end if

    !> RESUME/SAVERESUME 1 or 2 are not supported.
    if (RESUMEFLAG == 1 .or. SAVERESUMEFLAG == 1 .or. RESUMEFLAG == 2 .or. SAVERESUMEFLAG == 2) then
        write(line, "('RESUMEFLAG ', i1, ' and SAVERESUMEFLAG ', i1, ' are not supported.')") RESUMEFLAG, SAVERESUMEFLAG
        call print_error(line)
        call print_message('Use RESUMEFLAG 4 and SAVERESUMEFLAG 4 instead.')
        call program_abort()
    end if

!> ********************************************************************
!> RESUMEFLAG
!> ********************************************************************

      !> Check if we are reading in a resume_state.r2c file
!+    if (RESUMEFLAG == 2) then
!+        call print_screen('Reading saved state variables')

          !> Allocate arrays for resume_state_r2c
!+        open(54, file = 'resume_state_r2c.txt', action = 'read')
!+        read(54, *, iostat = ierr) NR2C_R, DELTR2C_R
!+        if (ierr == 0) then
!+            allocate(GRD_R(NR2C_R), GAT_R(NR2C_R), GRDGAT_R(NR2C_R), R2C_ATTRIBUTES_R(NR2C_R, 3), stat = ierr)
!+            if (ierr /= 0) then
!+                call print_error('Unable to allocate variables for RESUMESTATE 2.')
!+                call print_message('Check the value of the first record at the first line in resume_state_r2c.txt.')
!+                call print_message('The value should be an integer value greater than zero.')
!+                call program_abort()
!+            end if
!+        end if
!+        close(54)

         !> start by gathering from ROW to GAT so as not to mess-up with CLASSS after call to save_state_r2c
!        call CLASSG (cpv%TBAR, cpv%THLQ, cpv%THIC, cpv%TPND, cpv%ZPND, &
!                     cpv%TBAS, cpv%ALBS, cpv%TSNO, cpv%RHOS, cpv%SNO, &
!                     cpv%TCAN, cpv%RCAN, cpv%SNCAN, cpv%GRO, FRZCGAT, cpv%CMAI, &
!                     csfv%FCAN, csfv%LNZ0, csfv%ALVC, csfv%ALIC, csfv%PAMX, &
!                     csfv%PAMN, csfv%CMAS, csfv%ROOT, csfv%RSMN, csfv%QA50, &
!                     csfv%VPDA, csfv%VPDB, csfv%PSGA, csfv%PSGB, csfv%PAID, &
!                     csfv%HGTD, csfv%ACVD, csfv%ACID, cpv%TSFS, cpv%WSNO, &
!                     csfv%THP, csfv%THR, csfv%THM, csfv%BI, csfv%PSIS, &
!                     csfv%GRKS, csfv%THRA, csfv%HCPS, csfv%TCS, csfv%IGDR, &
!                     csfv%THFC, csfv%PSIW, csfv%DELZW, csfv%ZBTW, cfi%VMOD, &
!                     csfv%ZSNL, csfv%ZPLG, csfv%ZPLS, cpv%TAC, cpv%QAC, &
!                     csfv%DRN, csfv%XSLP, XDGAT, csfv%WFSF, KSGAT, &
!                     csfv%ALGW, csfv%ALGD, csfv%ASVD, csfv%ASID, csfv%AGVD, &
!                     csfv%AGID, csfv%ISND, catv%RADJ, catv%ZBLD, catv%Z0OR, &
!                     catv%ZRFM, catv%ZRFH, catv%ZDM, catv%ZDH, cfi%FSVH, &
!                     cfi%FSIH, catv%CSZ, cfi%FDL, cfi%UL, cfi%VL, &
!                     cfi%TA, cfi%QA, cfi%PRES, cfi%PRE, catv%PADR, &
!                     catv%VPD, catv%TADP, catv%RHOA, catv%RPCP, catv%TRPC, &
!                     catv%SPCP, catv%TSPC, catv%RHSI, catv%FCLO, catv%DLON, &
!                     catv%GGEO, &
!                     cdv%CDH, cdv%CDM, cdv%HFS, cdv%TFX, cdv%QEVP, &
!                     cdv%QFS, cdv%QFX, cdv%PET, cdv%GA, cdv%EF, &
!                     cdv%GTE, cdv%QG, cdv%ALVS, cdv%ALIR, &
!                     cdv%SFCT, cdv%SFCU, cdv%SFCV, cdv%SFCQ, cdv%FSNO, &
!                     cdv%FSGV, cdv%FSGS, cdv%FSGG, cdv%FLGV, cdv%FLGS, &
!                     cdv%FLGG, cdv%HFSC, cdv%HFSS, cdv%HFSG, cdv%HEVC, &
!                     cdv%HEVS, cdv%HEVG, cdv%HMFC, cdv%HMFN, cdv%HTCC, &
!                     cdv%HTCS, cdv%PCFC, cdv%PCLC, cdv%PCPN, cdv%PCPG, &
!                     cdv%QFG, cdv%QFN, cdv%QFCL, cdv%QFCF, cdv%ROF, &
!                     cdv%ROFO, cdv%ROFS, cdv%ROFB, cdv%TROF, cdv%TROO, &
!                     cdv%TROS, cdv%TROB, cdv%ROFC, cdv%ROFN, cdv%ROVG, &
!                     cdv%WTRC, cdv%WTRS, cdv%WTRG, cdv%DR, cdv%GFLX, &
!                     cdv%HMFG, cdv%HTC, cdv%QFC, ITCTGAT, &
!BEGIN: PDMROF
!                     CMINPDM, CMAXPDM, BPDM, K1PDM, K2PDM, &
!END: PDMROF
!                     shd%lc%ILMOS, shd%lc%JLMOS, shd%wc%ILMOS, shd%wc%JLMOS, shd%NA, shd%lc%NTYPE, &
!                     shd%lc%NML, il1, il2, shd%lc%IGND, ICAN, ICP1, cp%TBARROW, cp%THLQROW, &
!                     cp%THICROW, cp%TPNDROW, cp%ZPNDROW, TBASROW, cp%ALBSROW, &
!                     cp%TSNOROW, cp%RHOSROW, cp%SNOROW, cp%TCANROW, &
!                     cp%RCANROW, cp%SCANROW, cp%GROROW, CMAIROW, cp%FCANROW, &
!                     cp%LNZ0ROW, cp%ALVCROW, cp%ALICROW, cp%PAMXROW, &
!                     cp%PAMNROW, cp%CMASROW, cp%ROOTROW, cp%RSMNROW, &
!                     cp%QA50ROW, cp%VPDAROW, cp%VPDBROW, cp%PSGAROW, &
!                     cp%PSGBROW, PAIDROW, HGTDROW, ACVDROW, ACIDROW, TSFSROW, &
!                     WSNOROW, THPROW, THRROW, THMROW, BIROW, PSISROW, &
!                     GRKSROW, THRAROW, HCPSROW, TCSROW, IGDRROW, &
!                     THFCROW, PSIWROW, DLZWROW, ZBTWROW, VMODGRD, &
!                     hp%ZSNLROW, hp%ZPLGROW, hp%ZPLSROW, hp%FRZCROW, TACROW, QACROW, &
!                     cp%DRNROW, cp%XSLPROW, cp%XDROW, WFSFROW, cp%KSROW, &
!                     ALGWROW, ALGDROW, ASVDROW, ASIDROW, AGVDROW, &
!                     AGIDROW, ISNDROW, RADJGRD, cp%ZBLDGRD, Z0ORGRD, &
!                     cp%ZRFMGRD, cp%ZRFHGRD, ZDMGRD, ZDHGRD, vs%grid%fsin/2.0, &
!                     vs%grid%fsin/2.0, CSZGRD, vs%grid%flin, vs%grid%uv, VLGRD, &
!                     vs%grid%ta, vs%grid%qa, vs%grid%pres, &
!                     vs%grid%pre, PADRGRD, &
!                     VPDGRD, TADPGRD, RHOAGRD, RPCPGRD, TRPCGRD, &
!                     SPCPGRD, TSPCGRD, RHSIGRD, FCLOGRD, DLONGRD, &
!                     GGEOGRD, cp%MANNROW, MANNGAT, cp%DDROW, DDGAT, &
!                     cp%SANDROW, csfv%SAND, cp%CLAYROW, csfv%CLAY, &
!BEGIN: PDMROF
!                     hp%CMINROW, hp%CMAXROW, hp%BROW, hp%K1ROW, hp%K2ROW, &
!END: PDMROF
!                     cp%FAREROW, csfv%FARE, &
!                     hp%fetchROW, hp%HtROW, hp%N_SROW, hp%A_SROW, hp%DistribROW, &
!                     fetchGAT, HtGAT, N_SGAT, A_SGAT, DistribGAT, &
!                     DrySnowRow, SnowAgeROW, DrySnowGAT, SnowAgeGAT, &
!                     TSNOdsROW, RHOSdsROW, TSNOdsGAT, RHOSdsGAT, &
!                     DriftROW, SublROW, DepositionROW, &
!                     DriftGAT, SublGAT, DepositionGAT)

!        cdv%CDH = 0.0
!        cdv%CDM = 0.0
!        cdv%HFS = 0.0
!        cdv%TFX = 0.0
!        cdv%QEVP = 0.0
!        cdv%QFS = 0.0
!        cdv%QFX = 0.0
!        cdv%PET = 0.0
!        cdv%GA = 0.0
!        cdv%EF = 0.0
!        cdv%GTE = 0.0
!        cdv%QG = 0.0
!        cdv%ALVS = 0.0
!        cdv%ALIR = 0.0
!        cdv%SFCT = 0.0
!        cdv%SFCU = 0.0
!        cdv%SFCV = 0.0
!        cdv%SFCQ = 0.0
!        cdv%FSNO = 0.0
!        cdv%FSGV = 0.0
!        cdv%FSGS = 0.0
!        cdv%FSGG = 0.0
!        cdv%FLGV = 0.0
!        cdv%FLGS = 0.0
!        cdv%FLGG = 0.0
!        cdv%HFSC = 0.0
!        cdv%HFSS = 0.0
!        cdv%HFSG = 0.0
!        cdv%HEVC = 0.0
!        cdv%HEVS = 0.0
!        cdv%HEVG = 0.0
!        cdv%HMFC = 0.0
!        cdv%HMFN = 0.0
!        cdv%HTCC = 0.0
!        cdv%HTCS = 0.0
!        cdv%PCFC = 0.0
!        cdv%PCLC = 0.0
!        cdv%PCPN = 0.0
!        cdv%PCPG = 0.0
!        cdv%QFG = 0.0
!        cdv%QFN = 0.0
!        cdv%QFCF = 0.0
!        cdv%QFCL = 0.0
!        cdv%ROF = 0.0
!        cdv%ROFO = 0.0
!        cdv%ROFS = 0.0
!        cdv%ROFB = 0.0
!        cdv%TROF = 0.0
!        cdv%TROO = 0.0
!        cdv%TROS = 0.0
!        cdv%TROB = 0.0
!        cdv%ROFC = 0.0
!        cdv%ROFN = 0.0
!        cdv%ROVG = 0.0
!        cdv%WTRC = 0.0
!        cdv%WTRS = 0.0
!        cdv%WTRG = 0.0
!        cdv%DR = 0.0
!        cdv%HMFG = 0.0
!        cdv%HTC = 0.0
!        cdv%QFC = 0.0
!        cdv%GFLX = 0.0
!        ITCTGAT = 0

!+        call resume_state_r2c(shd%lc%NML, shd%NA, shd%lc%NTYPE, ic%ts_daily, &
!+                              ic%now%mins, shd%lc%ACLASS, NR2C_R, GRD_R, GAT_R, GRDGAT_R, R2C_ATTRIBUTES_R, &
!+                              shd%NA, shd%xxx, shd%yyy, shd%xCount, shd%yCount, shd%lc%ILMOS, shd%lc%JLMOS, shd%lc%NML, ICAN, ICP1, shd%lc%IGND, &
!+                              cpv%TBAR, cpv%THLQ, cpv%THIC, cpv%TPND, cpv%ZPND, &
!+                              cpv%TBAS, cpv%ALBS, cpv%TSNO, cpv%RHOS, cpv%SNO, &
!+                              cpv%TCAN, cpv%RCAN, cpv%SNCAN, cpv%GRO, cpv%CMAI, &
!+                              csfv%FCAN, csfv%LNZ0, csfv%ALVC, csfv%ALIC, csfv%PAMX, &
!+                              csfv%PAMN, csfv%CMAS, csfv%ROOT, csfv%RSMN, csfv%QA50, &
!+                              csfv%VPDA, csfv%VPDB, csfv%PSGA, csfv%PSGB, csfv%PAID, &
!+                              csfv%HGTD, csfv%ACVD, csfv%ACID, cpv%TSFS, cpv%WSNO, &
!+                              csfv%THP, csfv%THR, csfv%THM, csfv%BI, csfv%PSIS, &
!+                              csfv%GRKS, csfv%THRA, csfv%HCPS, csfv%TCS, &
!+                              csfv%THFC, csfv%PSIW, csfv%DELZW, csfv%ZBTW, &
!+                              csfv%ZSNL, csfv%ZPLG, csfv%ZPLS, cpv%TAC, cpv%QAC, &
!+                              csfv%DRN, csfv%XSLP, XDGAT, csfv%WFSF, KSGAT, &
!+                              csfv%ALGW, csfv%ALGD, csfv%ASVD, csfv%ASID, csfv%AGVD, &
!+                              csfv%AGID, csfv%ISND, catv%RADJ, catv%ZBLD, catv%Z0OR, &
!+                              catv%ZRFM, catv%ZRFH, catv%ZDM, catv%ZDH, cfi%FSVH, &
!+                              cfi%FSIH, catv%CSZ, cfi%FDL, cfi%UL, cfi%VL, &
!+                              cfi%TA, cfi%QA, cfi%PRES, cfi%PRE, catv%PADR, &
!+                              catv%VPD, catv%TADP, catv%RHOA, catv%RPCP, catv%TRPC, &
!+                              catv%SPCP, catv%TSPC, catv%RHSI, catv%FCLO, catv%DLON, &
!+                              catv%GGEO, &
!+                              cdv%CDH, cdv%CDM, cdv%HFS, cdv%TFX, cdv%QEVP, &
!+                              cdv%QFS, cdv%QFX, cdv%PET, cdv%GA, cdv%EF, &
!+                              cdv%GTE, cdv%QG, cdv%ALVS, cdv%ALIR, &
!+                              cdv%SFCT, cdv%SFCU, cdv%SFCV, cdv%SFCQ, cdv%FSNO, &
!+                              cdv%FSGV, cdv%FSGS, cdv%FSGG, cdv%FLGV, cdv%FLGS, &
!+                              cdv%FLGG, cdv%HFSC, cdv%HFSS, cdv%HFSG, cdv%HEVC, &
!+                              cdv%HEVS, cdv%HEVG, cdv%HMFC, cdv%HMFN, cdv%HTCC, &
!+                              cdv%HTCS, cdv%PCFC, cdv%PCLC, cdv%PCPN, cdv%PCPG, &
!+                              cdv%QFG, cdv%QFN, cdv%QFCL, cdv%QFCF, cdv%ROF, &
!+                              cdv%ROFO, cdv%ROFS, cdv%ROFB, cdv%TROF, cdv%TROO, &
!+                              cdv%TROS, cdv%TROB, cdv%ROFC, cdv%ROFN, cdv%ROVG, &
!+                              cdv%WTRC, cdv%WTRS, cdv%WTRG, cdv%DR, cdv%GFLX, &
!+                              cdv%HMFG, cdv%HTC, cdv%QFC, MANNGAT, DDGAT, &
!+                              csfv%SAND, csfv%CLAY, csfv%IGDR, cfi%VMOD, QLWOGAT, &
!+                              shd%CoordSys%Proj, shd%CoordSys%Ellips, shd%CoordSys%Zone, &
!+                              shd%xOrigin, shd%yOrigin, shd%xDelta, shd%yDelta)

         !> now scatter the variables so that the GATs don't get overwritten incorrectly
!        call CLASSS(cp%TBARROW, cp%THLQROW, cp%THICROW, GFLXROW, TSFSROW, &
!                    cp%TPNDROW, cp%ZPNDROW, TBASROW, cp%ALBSROW, cp%TSNOROW, &
!                    cp%RHOSROW, cp%SNOROW, cp%TCANROW, cp%RCANROW, cp%SCANROW, &
!                    cp%GROROW, CMAIROW, TACROW, QACROW, WSNOROW, &
!                    shd%lc%ILMOS, shd%lc%JLMOS, shd%wc%ILMOS, shd%wc%JLMOS, &
!                    shd%NA, shd%lc%NTYPE, shd%lc%NML, il1, il2, shd%lc%IGND, ICAN, ICAN + 1, &
!                    cpv%TBAR, cpv%THLQ, cpv%THIC, cdv%GFLX, cpv%TSFS, &
!                    cpv%TPND, cpv%ZPND, cpv%TBAS, cpv%ALBS, cpv%TSNO, &
!                    cpv%RHOS, cpv%SNO, cpv%TCAN, cpv%RCAN, cpv%SNCAN, &
!                    cpv%GRO, cpv%CMAI, cpv%TAC, cpv%QAC, cpv%WSNO, &
!                    cp%MANNROW, MANNGAT, cp%DDROW, DDGAT, &
!                    cp%SANDROW, csfv%SAND, cp%CLAYROW, csfv%CLAY, cp%XSLPROW, csfv%XSLP, &
!                    DrySnowRow, SnowAgeROW, DrySnowGAT, SnowAgeGAT, &
!                    TSNOdsROW, RHOSdsROW, TSNOdsGAT, RHOSdsGAT, &
!                    DriftROW, SublROW, DepositionROW, &
!                    DriftGAT, SublGAT, DepositionGAT)

!        do 180 k = il1, il2
!            ik = shd%lc%ILMOS(k)
!            jk = shd%lc%JLMOS(k)
!            CDHROW(ik, jk) = cdv%CDH(k)
!            CDMROW(ik, jk) = cdv%CDM(k)
!            HFSROW(ik, jk) = cdv%HFS(k)
!            TFXROW(ik, jk) = cdv%TFX(k)
!            QEVPROW(ik, jk) = cdv%QEVP(k)
!            QFSROW(ik, jk) = cdv%QFS(k)
!            QFXROW(ik, jk) = cdv%QFX(k)
!            PETROW(ik, jk) = cdv%PET(k)
!            GAROW(ik, jk) = cdv%GA(k)
!            EFROW(ik, jk) = cdv%EF(k)
!            GTROW(ik, jk) = cdv%GTE(k)
!            QGROW(ik, jk) = cdv%QG(k)
!            ALVSROW(ik, jk) = cdv%ALVS(k)
!            ALIRROW(ik, jk) = cdv%ALIR(k)
!            SFCTROW(ik, jk) = cdv%SFCT(k)
!            SFCUROW(ik, jk) = cdv%SFCU(k)
!            SFCVROW(ik, jk) = cdv%SFCV(k)
!            SFCQROW(ik, jk) = cdv%SFCQ(k)
!            FSNOROW(ik, jk) = cdv%FSNO(k)
!            FSGVROW(ik, jk) = cdv%FSGV(k)
!            FSGSROW(ik, jk) = cdv%FSGS(k)
!            FSGGROW(ik, jk) = cdv%FSGG(k)
!            FLGVROW(ik, jk) = cdv%FLGV(k)
!            FLGSROW(ik, jk) = cdv%FLGS(k)
!            FLGGROW(ik, jk) = cdv%FLGG(k)
!            HFSCROW(ik, jk) = cdv%HFSC(k)
!            HFSSROW(ik, jk) = cdv%HFSS(k)
!            HFSGROW(ik, jk) = cdv%HFSG(k)
!            HEVCROW(ik, jk) = cdv%HEVC(k)
!            HEVSROW(ik, jk) = cdv%HEVS(k)
!            HEVGROW(ik, jk) = cdv%HEVG(k)
!            HMFCROW(ik, jk) = cdv%HMFC(k)
!            HMFNROW(ik, jk) = cdv%HMFN(k)
!            HTCCROW(ik, jk) = cdv%HTCC(k)
!            HTCSROW(ik, jk) = cdv%HTCS(k)
!            PCFCROW(ik, jk) = cdv%PCFC(k)
!            PCLCROW(ik, jk) = cdv%PCLC(k)
!            PCPNROW(ik, jk) = cdv%PCPN(k)
!            PCPGROW(ik, jk) = cdv%PCPG(k)
!            QFGROW(ik, jk) = cdv%QFG(k)
!            QFNROW(ik, jk) = cdv%QFN(k)
!            QFCLROW(ik, jk) = cdv%QFCL(k)
!            QFCFROW(ik, jk) = cdv%QFCF(k)
!            ROFROW(ik, jk) = cdv%ROF(k)
!            ROFOROW(ik, jk) = cdv%ROFO(k)
!            ROFSROW(ik, jk) = cdv%ROFS(k)
!            ROFBROW(ik, jk) = cdv%ROFB(k)
!            TROFROW(ik, jk) = cdv%TROF(k)
!            TROOROW(ik, jk) = cdv%TROO(k)
!            TROSROW(ik, jk) = cdv%TROS(k)
!            TROBROW(ik, jk) = cdv%TROB(k)
!            ROFCROW(ik, jk) = cdv%ROFC(k)
!            ROFNROW(ik, jk) = cdv%ROFN(k)
!            ROVGROW(ik, jk) = cdv%ROVG(k)
!            WTRCROW(ik, jk) = cdv%WTRC(k)
!            WTRSROW(ik, jk) = cdv%WTRS(k)
!            WTRGROW(ik, jk) = cdv%WTRG(k)
!            DRROW(ik, jk) = cdv%DR(k)
!            WTABROW(ik, jk) = cdv%WTAB(k)
!            ILMOROW(ik, jk) = cdv%ILMO(k)
!            UEROW(ik, jk) = cdv%UE(k)
!            HBLROW(ik, jk) = cdv%HBL(k)
!180     continue

!        do 190 l = 1, shd%lc%IGND
!            do 190 k = il1, il2
!                ik = shd%lc%ILMOS(k)
!                jk = shd%lc%JLMOS(k)
!                HMFGROW(ik, jk, l) = cdv%HMFG(k, l)
!                HTCROW(ik, jk, l) = cdv%HTC(k, l)
!                QFCROW(ik, jk, l) = cdv%QFC(k, l)
!190     continue

!        do 230 m = 1, 50
!            do 220 l = 1, 6
!                do 210 k = il1, il2
!                    ITCTROW(shd%lc%ILMOS(k), shd%lc%JLMOS(k), l, m) = ITCTGAT(k, l, m)
!210     continue
!220     continue
!230     continue
!+    end if !(RESUMEFLAG == 2) then

    !> Update initial values.
    ltest = .false.
    inquire(file = 'MESH_initial_values.r2c', exist = ltest)
    if (ltest) then
        ierr = 0
        call read_initial_values_r2c(shd, 100, 'MESH_initial_values.r2c', ierr)
        call reset_tab()
        call MPI_Barrier(MPI_COMM_WORLD, z)
        if (ierr /= 0) then
            call print_error('Errors occurred during reading values from file.')
            if (ISHEADNODE) call program_abort()
        end if
    end if

    !> Update output variables with initial states.
    call output_variables_reset(shd)
    call output_variables_update(shd)

    !> Calculate initial storage.
    if (ro%RUNBALWB .and. ISHEADNODE) then
        STG_INI = sum( &
            (out%ts%grid%rcan(1:shd%NA) + out%ts%grid%sncan(1:shd%NA) + &
             out%ts%grid%sno(1:shd%NA) + out%ts%grid%wsno(1:shd%NA) + out%ts%grid%pndw(1:shd%NA) + &
             out%ts%grid%lzs(1:shd%NA) + out%ts%grid%dzs(1:shd%NA) + &
             sum(out%ts%grid%lqws(1:shd%NA, :), 2) + sum(out%ts%grid%fzws(1:shd%NA, :), 2))*shd%FRAC)
        STG_INI = STG_INI/sum(shd%FRAC)
    end if

    !> Read in existing basin states for RESUMEFLAG.
    if (RESUMEFLAG == 4) then

        !> Open the resume file for the driver.
        iun = fls%fl(mfk%f883)%iun
        open(iun, file = trim(adjustl(fls%fl(mfk%f883)%fn)) // '.mesh_driver', status = 'old', action = 'read', &
             form = 'unformatted', access = 'sequential', iostat = ierr)
!todo: condition for ierr.

        !> Time-stepping information.
        read(iun) ic%now%year, ic%now%jday, ic%now%month, ic%now%day, ic%now%hour, ic%now%mins
        read(iun) ic%iter%year, ic%iter%jday, ic%iter%month, ic%iter%jday, ic%iter%hour, ic%iter%mins
        read(iun) ic%ts_daily, ic%ts_hourly, ic%ts_halfhourly, ic%ts_count

        !> Read states for the driver (for the head node or in serial).
        if (ISHEADNODE) then

            !> Water balance totals.
            read(iun) TOTAL_PRE, TOTAL_EVAP, TOTAL_ROF, TOTAL_ROFO, TOTAL_ROFS, TOTAL_ROFB
            read(iun) STG_INI

            !> Daily streamflow values.
            read(iun) fms%stmg%qomeas%val
            read(iun) out%d%grid%qo(fms%stmg%meta%rnk(:))

        end if

        !> Close the file to free the unit.
        close(iun)

    end if !(RESUMEFLAG == 4) then

    !> Update 'next' counter.
    call counter_init()

    if (ISHEADNODE .and. mtsflg%AUTOCALIBRATIONFLAG > 0) call stats_init(fls)

    !> *********************************************************************
    !> End of Initialization
    !> *********************************************************************

    call print_screen('')
    call print_screen('')
    call print_screen('DONE INTITIALIZATION')
    call print_screen('')
    call print_screen('STARTING MESH')

    !> *********************************************************************
    !> Start of main loop that is run each half hour
    !> *********************************************************************

    !> MAM - Initialize ENDDATE and ENDDATA.
    ENDDATE = .false.
    ENDDATA = .false.

    do while (.not. ENDDATE .and. .not. ENDDATA)

        !> Reset output variables.
        call output_variables_reset(shd)

        !> Load or update climate forcing input.
        if (ro%RUNCLIM) then
            ENDDATA = climate_module_update_data(fls, shd, il1, il2, cm)
            if (ENDDATA) exit
        end if

        !> Distribute grid states (e.g., channel storage) to worker nodes.
        if (ro%RUNGRID) call run_within_grid_mpi_irecv(fls, shd, cm)

        !> Run tile-based processes.
        if (ro%RUNTILE) then
            call run_within_tile(fls, shd, cm)
            call run_within_grid(fls, shd, cm)
        end if

        !> Update grid states (e.g., channel storage) from worker nodes.
        if (ro%RUNGRID) call run_within_grid_mpi_isend(fls, shd, cm)

        !> Run grid-based processes.
        if (ro%RUNGRID) call run_between_grid(fls, shd, cm)

        !> Update output variables.
!todo: Enable this when the one in 'run_between_grid' is removed.
!+        call output_variables_update(shd)

        !> *********************************************************************
        !> Start of book-keeping and grid accumulation.
        !> *********************************************************************

        if (ISHEADNODE) then

            !> Write ENSIM output
            if (NR2CFILES > 0 .and. mod(ic%ts_daily*30, DELTR2C) == 0) then
!                call FIND_MONTH (ic%now%jday, ic%now%year, ensim_month)
!                call FIND_DAY (ic%now%jday, ic%now%year, ensim_day)
!                call WRITE_R2C_DATA(shd%lc%NML, shd%NA, shd%lc%NTYPE, ic%ts_daily, ic%now%mins, shd%lc%ACLASS, &
!                                    shd%NA, shd%xxx, shd%yyy, shd%xCount, shd%yCount, shd%lc%ILMOS, shd%lc%JLMOS, shd%lc%NML, &
!                                    NR2C, NR2CFILES, R2CFILEUNITSTART, GRD, GAT, &
!                                    GRDGAT, NR2CSTATES, R2C_ATTRIBUTES, FRAME_NO_NEW, ic%now%year, &
!                                    ensim_MONTH, ensim_DAY, ic%now%hour, ic%now%mins, ICAN, &
!                                    ICAN + 1, shd%lc%IGND, &
!                                    cpv%TBAR, cpv%THLQ, cpv%THIC, cpv%TPND, cpv%ZPND, &
!                                    cpv%TBAS, cpv%ALBS, cpv%TSNO, cpv%RHOS, cpv%SNO, &
!                                    cpv%TCAN, cpv%RCAN, cpv%SNCAN, cpv%GRO, cpv%CMAI, &
!                                    csfv%FCAN, csfv%LNZ0, csfv%ALVC, csfv%ALIC, csfv%PAMX, &
!                                    csfv%PAMN, csfv%CMAS, csfv%ROOT, csfv%RSMN, csfv%QA50, &
!                                    csfv%VPDA, csfv%VPDB, csfv%PSGA, csfv%PSGB, csfv%PAID, &
!                                    csfv%HGTD, csfv%ACVD, csfv%ACID, cpv%TSFS, cpv%WSNO, &
!                                    csfv%THP, csfv%THR, csfv%THM, csfv%BI, csfv%PSIS, &
!                                    csfv%GRKS, csfv%THRA, csfv%HCPS, csfv%TCS, &
!                                    csfv%THFC, csfv%PSIW, csfv%DELZW, csfv%ZBTW, &
!                                    csfv%ZSNL, csfv%ZPLG, csfv%ZPLS, cpv%TAC, cpv%QAC, &
!                                    csfv%DRN, csfv%XSLP, XDGAT, csfv%WFSF, KSGAT, &
!                                    csfv%ALGW, csfv%ALGD, csfv%ASVD, csfv%ASID, csfv%AGVD, &
!                                    csfv%AGID, csfv%ISND, catv%RADJ, catv%ZBLD, catv%Z0OR, &
!                                    catv%ZRFM, catv%ZRFH, catv%ZDM, catv%ZDH, cfi%FSVH, &
!                                    cfi%FSIH, catv%CSZ, cfi%FDL, cfi%UL, cfi%VL, &
!                                    cfi%TA, cfi%QA, cfi%PRES, cfi%PRE, catv%PADR, &
!                                    catv%VPD, catv%TADP, catv%RHOA, catv%RPCP, catv%TRPC, &
!                                    catv%SPCP, catv%TSPC, catv%RHSI, catv%FCLO, catv%DLON, &
!                                    catv%GGEO, &
!                                    cdv%CDH, cdv%CDM, cdv%HFS, cdv%TFX, cdv%QEVP, &
!                                    cdv%QFS, cdv%QFX, cdv%PET, cdv%GA, cdv%EF, &
!                                    cdv%GTE, cdv%QG, cdv%ALVS, cdv%ALIR, &
!                                    cdv%SFCT, cdv%SFCU, cdv%SFCV, cdv%SFCQ, cdv%FSNO, &
!                                    cdv%FSGV, cdv%FSGS, cdv%FSGG, cdv%FLGV, cdv%FLGS, &
!                                    cdv%FLGG, cdv%HFSC, cdv%HFSS, cdv%HFSG, cdv%HEVC, &
!                                    cdv%HEVS, cdv%HEVG, cdv%HMFC, cdv%HMFN, cdv%HTCC, &
!                                    cdv%HTCS, cdv%PCFC, cdv%PCLC, cdv%PCPN, cdv%PCPG, &
!                                    cdv%QFG, cdv%QFN, cdv%QFCL, cdv%QFCF, cdv%ROF, &
!                                    cdv%ROFO, cdv%ROFS, cdv%ROFB, cdv%TROF, cdv%TROO, &
!                                    cdv%TROS, cdv%TROB, cdv%ROFC, cdv%ROFN, cdv%ROVG, &
!                                    cdv%WTRC, cdv%WTRS, cdv%WTRG, cdv%DR, cdv%GFLX, &
!                                    cdv%HMFG, cdv%HTC, cdv%QFC, MANNGAT, DDGAT, &
!                                    csfv%IGDR, cfi%VMOD, QLWOGAT)
                FRAME_NO_NEW = FRAME_NO_NEW + 1 !UPDATE COUNTERS
            end if

            !> Update output files.
            call output_files_update(fls, shd)
            call run_save_basin_output(fls, shd, cm)

            !> Metrics and pre-emption.
            if (ic%now%day /= ic%next%day .and. mtsflg%AUTOCALIBRATIONFLAG > 0) then
                call stats_update_stfl_daily(fls)
                if (mtsflg%PREEMPTIONFLAG > 1) then
                    if (FTEST > FBEST) goto 98
                end if
            end if

            !> Write output to the console.
            if (PRINTSIMSTATUS /= OUT_NONE) then

                !> Daily.
                if ((PRINTSIMSTATUS == OUT_JDATE_DLY .or. PRINTSIMSTATUS == OUT_DATE_DLY) .and. &
                    ic%now%day /= ic%next%day) then
                    select case (PRINTSIMSTATUS)
                        case (OUT_DATE_DLY)
                            write(line, "(i5, '/', i2.2, '/', i2.2)") ic%now%year, ic%now%month, ic%now%day
                        case default
                            write(line, '(i5, i4)') ic%now%year, ic%now%jday
                    end select
                    if (fms%stmg%n > 0) then
                        do j = 1, fms%stmg%n
                            if (fms%stmg%n > 0) write(line, '((a), f10.3)') trim(line), fms%stmg%qomeas%val(j)
                            write(line, '((a), f10.3)') trim(line), out%d%grid%qo(fms%stmg%meta%rnk(j))
                        end do
                    end if
                    if (ro%RUNBALWB) then
                        write(line, '((a), 3(f10.3))') &
                            trim(line), &
                            sum(out%d%grid%prec(1:shd%NA)*shd%FRAC)/sum(shd%FRAC), &
                            sum(out%d%grid%evap(1:shd%NA)*shd%FRAC)*ic%dts/sum(shd%FRAC), &
                            sum(out%d%grid%rof(1:shd%NA)*shd%FRAC)*ic%dts/sum(shd%FRAC)
                    end if
                    call print_screen(line)
                end if

                !> Monthly.
                if ((PRINTSIMSTATUS == OUT_JDATE_MLY .or. PRINTSIMSTATUS == OUT_DATE_MLY) .and. &
                    ic%now%month /= ic%next%month) then
                    select case (PRINTSIMSTATUS)
                        case (OUT_DATE_MLY)
                            write(line, "(i5, '/', i2.2, '/', i2.2)") ic%now%year, ic%now%month, ic%now%day
                        case default
                            write(line, '(i5, i4)') ic%now%year, ic%now%jday
                    end select
                    if (ro%RUNBALWB) then
                        write(line, '((a), 3(f10.3))') &
                            trim(line), &
                            sum(out%m%grid%prec(1:shd%NA)*shd%FRAC)/sum(shd%FRAC), &
                            sum(out%m%grid%evap(1:shd%NA)*shd%FRAC)*ic%dts/sum(shd%FRAC), &
                            sum(out%m%grid%rof(1:shd%NA)*shd%FRAC)*ic%dts/sum(shd%FRAC)
                    end if
                    call print_screen(line)
                end if
            end if
        end if

        !> Update the current time-step and counter.
        call counter_update()

        !> Check if we should terminate the run yet.
        if (ic%now%year >= ic%stop%year .and. ic%stop%year > 0) then
            if (ic%now%year > ic%stop%year) then
                ENDDATE = .true.
            else if (ic%now%year == ic%stop%year .and. ic%now%jday >= ic%stop%jday) then
                if (ic%now%jday > ic%stop%jday) then
                    ENDDATE = .true.
                else if (ic%now%jday == ic%stop%jday .and. ic%now%hour >= ic%stop%hour) then
                    if (ic%now%hour > ic%stop%hour) then
                        ENDDATE = .true.
                    else if (ic%now%hour == ic%stop%hour .and. ic%now%mins >= ic%stop%mins) then
                        ENDDATE = .true.
                    end if
                end if
            end if
        end if

        !> Check the run state.
        if (ENDDATA .or. ENDDATE) exit

    end do !while (.not. ENDDATE .and. .not. ENDDATA)

    !> End of simulation termination point.
97  continue

    !> End program if not the head node.
    if (ipid /= 0) then
        if (DIAGNOSEMODE) then
            write(line, FMT_GEN) ipid
            call print_screen('Node ' // trim(adjustl(line)) // ' is existing.')
        end if
        goto 99
    end if

    !> *********************************************************************
    !> SAVERESUMEFLAG
    !> *********************************************************************

    !> Write the resume file
!+    if (SAVERESUMEFLAG == 2) then !todo: done: use a flag
!+        call print_screen('Saving state variables in r2c file format')

    !> Allocate arrays for save_state_r2c
!+        open(55, file = 'save_state_r2c.txt', action = 'read')
!+        read(55, *, iostat = ierr) NR2C_S, DELTR2C_S
!+        if (ierr == 0) then
!+            allocate(GRD_S(NR2C_S), GAT_S(NR2C_S), GRDGAT_S(NR2C_S), R2C_ATTRIBUTES_S(NR2C_S, 3), stat = ierr)
!+            if (ierr /= 0) then
!+                call print_error('Unable to allocate variables for SAVERESUMESTATE 2.')
!+                call print_message('Check the value of the first record at the first line in save_state_r2c.txt.')
!+                call print_message('The value should be an integer value greater than zero.')
!+                call program_abort()
!+            end if
!+        end if
!+        close(55)

!+        call SAVE_STATE_R2C(shd%lc%NML, shd%NA, shd%lc%NTYPE, ic%ts_daily, &
!+                            ic%now%mins, shd%lc%ACLASS, NR2C_S, GRD_S, GAT_S, GRDGAT_S, R2C_ATTRIBUTES_S, &
!+                            shd%NA, shd%xxx, shd%yyy, shd%xCount, shd%yCount, shd%lc%ILMOS, shd%lc%JLMOS, shd%lc%NML, ICAN, ICP1, shd%lc%IGND, &
!+                            cpv%TBAR, cpv%THLQ, cpv%THIC, cpv%TPND, cpv%ZPND, &
!+                            cpv%TBAS, cpv%ALBS, cpv%TSNO, cpv%RHOS, cpv%SNO, &
!+                            cpv%TCAN, cpv%RCAN, cpv%SNCAN, cpv%GRO, cpv%CMAI, &
!+                            csfv%FCAN, csfv%LNZ0, csfv%ALVC, csfv%ALIC, csfv%PAMX, &
!+                            csfv%PAMN, csfv%CMAS, csfv%ROOT, csfv%RSMN, csfv%QA50, &
!+                            csfv%VPDA, csfv%VPDB, csfv%PSGA, csfv%PSGB, csfv%PAID, &
!+                            csfv%HGTD, csfv%ACVD, csfv%ACID, cpv%TSFS, cpv%WSNO, &
!+                            csfv%THP, csfv%THR, csfv%THM, csfv%BI, csfv%PSIS, &
!+                            csfv%GRKS, csfv%THRA, csfv%HCPS, csfv%TCS, &
!+                            csfv%THFC, csfv%PSIW, csfv%DELZW, csfv%ZBTW, &
!+                            csfv%ZSNL, csfv%ZPLG, csfv%ZPLS, cpv%TAC, cpv%QAC, &
!+                            csfv%DRN, csfv%XSLP, XDGAT, csfv%WFSF, KSGAT, &
!+                            csfv%ALGW, csfv%ALGD, csfv%ASVD, csfv%ASID, csfv%AGVD, &
!+                            csfv%AGID, csfv%ISND, catv%RADJ, catv%ZBLD, catv%Z0OR, &
!+                            catv%ZRFM, catv%ZRFH, catv%ZDM, catv%ZDH, cfi%FSVH, &
!+                            cfi%FSIH, catv%CSZ, cfi%FDL, cfi%UL, cfi%VL, &
!+                            cfi%TA, cfi%QA, cfi%PRES, cfi%PRE, catv%PADR, &
!+                            catv%VPD, catv%TADP, catv%RHOA, catv%RPCP, catv%TRPC, &
!+                            catv%SPCP, catv%TSPC, catv%RHSI, catv%FCLO, catv%DLON, &
!+                            catv%GGEO, &
!+                            cdv%CDH, cdv%CDM, cdv%HFS, cdv%TFX, cdv%QEVP, &
!+                            cdv%QFS, cdv%QFX, cdv%PET, cdv%GA, cdv%EF, &
!+                            cdv%GTE, cdv%QG, cdv%ALVS, cdv%ALIR, &
!+                            cdv%SFCT, cdv%SFCU, cdv%SFCV, cdv%SFCQ, cdv%FSNO, &
!+                            cdv%FSGV, cdv%FSGS, cdv%FSGG, cdv%FLGV, cdv%FLGS, &
!+                            cdv%FLGG, cdv%HFSC, cdv%HFSS, cdv%HFSG, cdv%HEVC, &
!+                            cdv%HEVS, cdv%HEVG, cdv%HMFC, cdv%HMFN, cdv%HTCC, &
!+                            cdv%HTCS, cdv%PCFC, cdv%PCLC, cdv%PCPN, cdv%PCPG, &
!+                            cdv%QFG, cdv%QFN, cdv%QFCL, cdv%QFCF, cdv%ROF, &
!+                            cdv%ROFO, cdv%ROFS, cdv%ROFB, cdv%TROF, cdv%TROO, &
!+                            cdv%TROS, cdv%TROB, cdv%ROFC, cdv%ROFN, cdv%ROVG, &
!+                            cdv%WTRC, cdv%WTRS, cdv%WTRG, cdv%DR, cdv%GFLX, &
!+                            cdv%HMFG, cdv%HTC, cdv%QFC, MANNGAT, DDGAT, &
!+                            csfv%SAND, csfv%CLAY, csfv%IGDR, cfi%VMOD, QLWOGAT, &
!+                            shd%CoordSys%Proj, shd%CoordSys%Ellips, shd%CoordSys%Zone, &
!+                            shd%xOrigin, shd%yOrigin, shd%xDelta, shd%yDelta)
!+    end if !(SAVERESUMEFLAG == 2) then

    !> Close output files.
    call output_files_finalize(fls, shd)
    call run_save_basin_output_finalize(fls, shd, cm)

    !> *********************************************************************
    !> Run is now over, print final results to the screen and close files
    !> *********************************************************************

    if (ENDDATA) call print_message('Reached end of forcing data.')
    if (ENDDATE) call print_message('Reached simulation end date.')

    if (ISHEADNODE .and. mtsflg%AUTOCALIBRATIONFLAG > 0) call stats_write(fls)

    !> PREEMPTIONFLAG (FTEST) termination point.
98  continue

    !> Call finalization routines.
    if (ro%RUNTILE) then
        call run_within_tile_finalize(fls, shd, cm)
        call run_within_grid_finalize(fls, shd, cm)
    end if
    if (ro%RUNGRID) call run_between_grid_finalize(fls, shd, cm)
    if (ro%RUNCLIM) call climate_module_finalize(fls, shd, cm)

    if (ISHEADNODE) then

        !> Basin totals for the run.
        if (ro%RUNBALWB) then
            TOTAL_PRE = TOTAL_PRE + sum(out%tot%grid%prec(1:shd%NA)*shd%FRAC)/sum(shd%FRAC)
            TOTAL_EVAP = TOTAL_EVAP + sum(out%tot%grid%evap(1:shd%NA)*shd%FRAC)*ic%dts/sum(shd%FRAC)
            TOTAL_ROF = TOTAL_ROF + sum(out%tot%grid%rof(1:shd%NA)*shd%FRAC)*ic%dts/sum(shd%FRAC)
            TOTAL_ROFO = TOTAL_ROFO + sum(out%tot%grid%rofo(1:shd%NA)*shd%FRAC)*ic%dts/sum(shd%FRAC)
            TOTAL_ROFS = TOTAL_ROFS + sum(out%tot%grid%rofs(1:shd%NA)*shd%FRAC)*ic%dts/sum(shd%FRAC)
            TOTAL_ROFB = TOTAL_ROFB + sum(out%tot%grid%rofb(1:shd%NA)*shd%FRAC)*ic%dts/sum(shd%FRAC)
            STG_FIN = sum( &
                (out%ts%grid%rcan(1:shd%NA) + out%ts%grid%sncan(1:shd%NA) + &
                 out%ts%grid%sno(1:shd%NA) + out%ts%grid%wsno(1:shd%NA) + out%ts%grid%pndw(1:shd%NA) + &
                 out%ts%grid%lzs(1:shd%NA) + out%ts%grid%dzs(1:shd%NA) + &
                 sum(out%ts%grid%lqws(1:shd%NA, :), 2) + sum(out%ts%grid%fzws(1:shd%NA, :), 2))*shd%FRAC)/sum(shd%FRAC)
        end if

        !> Save the current state of the model for SAVERESUMEFLAG.
        if (SAVERESUMEFLAG == 4) then

            !> Open the resume file for the driver.
            iun = fls%fl(mfk%f883)%iun
            open(iun, file = trim(adjustl(fls%fl(mfk%f883)%fn)) // '.mesh_driver', status = 'replace', action = 'write', &
                 form = 'unformatted', access = 'sequential', iostat = ierr)
!todo: condition for ierr.

            !> Time-stepping information.
            write(iun) ic%now%year, ic%now%jday, ic%now%month, ic%now%day, ic%now%hour, ic%now%mins
            write(iun) ic%iter%year, ic%iter%jday, ic%iter%month, ic%iter%jday, ic%iter%hour, ic%iter%mins
            write(iun) ic%ts_daily, ic%ts_hourly, ic%ts_halfhourly, ic%ts_count

            !> Water balance totals.
            write(iun) TOTAL_PRE, TOTAL_EVAP, TOTAL_ROF, TOTAL_ROFO, TOTAL_ROFS, TOTAL_ROFB
            write(iun) STG_INI

            !> Daily streamflow values.
            write(iun) fms%stmg%qomeas%val
            write(iun) out%d%grid%qo(fms%stmg%meta%rnk(:))

            !> Close the file to free the unit.
            close(iun)

        end if !(SAVERESUMEFLAG == 4) then

        !> Write data to the output summary file.
        if (ECHOTXTMODE) then

            !> CLASS states for prognostic variables.
            NTYPE = shd%lc%NTYPE
            NSL = shd%lc%IGND
            NML = shd%lc%NML
            allocate(tcan(3, NTYPE), rcan(3, NTYPE), sncan(3, NTYPE), gro(3, NTYPE), zpnd(3, NTYPE), tpnd(3, NTYPE), &
                     sno(3, NTYPE), tsno(3, NTYPE), albs(3, NTYPE), rhos(3, NTYPE), &
                     tbar(3, NTYPE, NSL), thlq(3, NTYPE, NSL), thic(3, NTYPE, NSL), kc(NTYPE))
            tcan = 0.0; rcan = 0.0; sncan = 0.0; gro = 0.0; zpnd = 0.0; tpnd = 0.0
            sno = 0.0; tsno = 0.0; albs = 0.0; rhos = 0.0
            tbar = 0.0; thlq = 0.0; thic = 0.0; kc = 0

            !> Loop through the GRUs.
            do m = 1, NTYPE

                !> Cycle if the GRU does not exist.
                if (count(shd%lc%JLMOS(1:NML) == m) == 0) cycle

                !> Canopy.
                tcan(3, m) = maxval(vs%tile%tcan, shd%lc%JLMOS(1:NML) == m)
                if (tcan(3, m) > 0.0) then
                    tcan(1, m) = sum(vs%tile%tcan, shd%lc%JLMOS(1:NML) == m .and. &
                                     vs%tile%tcan /= 0.0)/count(shd%lc%JLMOS(1:NML) == m .and. vs%tile%tcan /= 0.0)
                    tcan(2, m) = minval(vs%tile%tcan, shd%lc%JLMOS(1:NML) == m .and. vs%tile%tcan /= 0.0)
                end if
                where (tcan < 173.16 .or. tcan > 373.16 .or. tcan == 0.0) tcan = 273.16
                rcan(2, m) = minval(vs%tile%rcan, shd%lc%JLMOS(1:NML) == m)
                rcan(3, m) = maxval(vs%tile%rcan, shd%lc%JLMOS(1:NML) == m)
                rcan(1, m) = sum(vs%tile%rcan, shd%lc%JLMOS(1:NML) == m)/count(shd%lc%JLMOS(1:NML) == m)
                sncan(2, m) = minval(vs%tile%sncan, shd%lc%JLMOS(1:NML) == m)
                sncan(3, m) = maxval(vs%tile%sncan, shd%lc%JLMOS(1:NML) == m)
                sncan(1, m) = sum(vs%tile%sncan, shd%lc%JLMOS(1:NML) == m)/count(shd%lc%JLMOS(1:NML) == m)
                gro(2, m) = minval(vs%tile%gro, shd%lc%JLMOS(1:NML) == m)
                gro(3, m) = maxval(vs%tile%gro, shd%lc%JLMOS(1:NML) == m)
                gro(1, m) = sum(vs%tile%gro, shd%lc%JLMOS(1:NML) == m)/count(shd%lc%JLMOS(1:NML) == m)

                !> Ponded water at surface.
                zpnd(2, m) = minval(vs%tile%zpnd, shd%lc%JLMOS(1:NML) == m)
                zpnd(3, m) = maxval(vs%tile%zpnd, shd%lc%JLMOS(1:NML) == m)
                zpnd(1, m) = sum(vs%tile%zpnd, shd%lc%JLMOS(1:NML) == m)/count(shd%lc%JLMOS(1:NML) == m)
                tpnd(3, m) = maxval(vs%tile%tpnd, shd%lc%JLMOS(1:NML) == m)
                if (tpnd(3, m) > 0.0) then
                    tpnd(1, m) = sum(vs%tile%tpnd, shd%lc%JLMOS(1:NML) == m .and. &
                                     vs%tile%tpnd /= 0.0)/count(shd%lc%JLMOS(1:NML) == m .and. vs%tile%tpnd /= 0.0)
                    tpnd(2, m) = minval(vs%tile%tpnd, shd%lc%JLMOS(1:NML) == m .and. vs%tile%tpnd /= 0.0)
                end if
                where (tpnd < 173.16 .or. tpnd > 373.16 .or. tpnd == 0.0) tpnd = 273.16

                !> Snow.
                sno(2, m) = minval(vs%tile%sno, shd%lc%JLMOS(1:NML) == m)
                sno(3, m) = maxval(vs%tile%sno, shd%lc%JLMOS(1:NML) == m)
                sno(1, m) = sum(vs%tile%sno, shd%lc%JLMOS(1:NML) == m)/count(shd%lc%JLMOS(1:NML) == m)
                tsno(3, m) = maxval(vs%tile%tsno, shd%lc%JLMOS(1:NML) == m)
                if (tsno(3, m) > 0.0) then
                    tsno(1, m) = sum(vs%tile%tsno, shd%lc%JLMOS(1:NML) == m .and. &
                                     vs%tile%tsno /= 0.0)/count(shd%lc%JLMOS(1:NML) == m .and. vs%tile%tsno /= 0.0)
                    tsno(2, m) = minval(vs%tile%tsno, shd%lc%JLMOS(1:NML) == m .and. vs%tile%tsno /= 0.0)
                end if
                where (tsno < 173.16 .or. tsno > 373.16 .or. tsno == 0.0) tsno = 273.16
                if (sno(3, m) > 0.0) then
                    albs(1, m) = sum(vs%tile%albs, shd%lc%JLMOS(1:NML) == m .and. &
                                     vs%tile%sno > 0.0)/count(shd%lc%JLMOS(1:NML) == m .and. vs%tile%sno > 0.0)
                    albs(2, m) = minval(vs%tile%albs, shd%lc%JLMOS(1:NML) == m .and. vs%tile%sno > 0.0)
                    albs(3, m) = maxval(vs%tile%albs, shd%lc%JLMOS(1:NML) == m .and. vs%tile%sno > 0.0)
                end if
                rhos(3, m) = maxval(vs%tile%rhos, shd%lc%JLMOS(1:NML) == m)
                if (rhos(3, m) > 0.0) then
                    rhos(1, m) = sum(vs%tile%rhos, shd%lc%JLMOS(1:NML) == m .and. &
                                     vs%tile%rhos /= 0.0)/count(shd%lc%JLMOS(1:NML) == m .and. vs%tile%rhos /= 0.0)
                    rhos(2, m) = minval(vs%tile%rhos, shd%lc%JLMOS(1:NML) == m .and. vs%tile%rhos /= 0.0)
                end if

                !> Soil.
                do j = 1, NSL
                    tbar(1, m, j) = sum(vs%tile%tbar(:, j), shd%lc%JLMOS(1:NML) == m)/count(shd%lc%JLMOS(1:NML) == m)
                    tbar(2, m, j) = minval(vs%tile%tbar(:, j), shd%lc%JLMOS(1:NML) == m)
                    tbar(3, m, j) = maxval(vs%tile%tbar(:, j), shd%lc%JLMOS(1:NML) == m)
                    thlq(1, m, j) = sum(vs%tile%thlq(:, j), shd%lc%JLMOS(1:NML) == m)/count(shd%lc%JLMOS(1:NML) == m)
                    thlq(2, m, j) = minval(vs%tile%thlq(:, j), shd%lc%JLMOS(1:NML) == m)
                    thlq(3, m, j) = maxval(vs%tile%thlq(:, j), shd%lc%JLMOS(1:NML) == m)
                    thic(1, m, j) = sum(vs%tile%thic(:, j), shd%lc%JLMOS(1:NML) == m)/count(shd%lc%JLMOS(1:NML) == m)
                    thic(2, m, j) = minval(vs%tile%thic(:, j), shd%lc%JLMOS(1:NML) == m)
                    thic(3, m, j) = maxval(vs%tile%thic(:, j), shd%lc%JLMOS(1:NML) == m)
                end do
            end do

            !> Write to file.
            if (NRSOILAYEREADFLAG > 3) then
                ignd = min(NRSOILAYEREADFLAG, NSL)
            else if (NRSOILAYEREADFLAG == 1) then
                ignd = NSL
            else
                ignd = 3
            end if
            write(cfmt, '(i3)') ignd
            write(ECHO_TXT_IUN, *)
            write(ECHO_TXT_IUN, '(a)') 'End of run prognostic states'
            write(ECHO_TXT_IUN, '(3x, (a), i4)') 'Number of GRUs: ', NTYPE
            do i = 1, 3
                write(ECHO_TXT_IUN, *)
                select case (i)
                    case (1); write(ECHO_TXT_IUN, '(a)') 'Average values'
                    case (2); write(ECHO_TXT_IUN, '(a)') 'Minimum values'
                    case (3); write(ECHO_TXT_IUN, '(a)') 'Maximum values'
                end select
                do m = 1, NTYPE
                    write(ECHO_TXT_IUN, "(3x, 'GRU ', i3, ':')") m
                    cfmtt = "(" // trim(adjustl(cfmt)) // "(f10.3), 3(f10.3), " // &
                            "2x, '!> TBAR(1:" // trim(adjustl(cfmt)) // ")/TCAN/TSNO/TPND')"
                    write(ECHO_TXT_IUN, cfmtt) ((tbar(i, m, j) - 273.16), j = 1, ignd), &
                        (tcan(i, m) - 273.16), (tsno(i, m) - 273.16), (tpnd(i, m) - 273.16)
                    cfmtt = "(" // trim(adjustl(cfmt)) // "(f10.3), " // trim(adjustl(cfmt)) // "(f10.3), f10.3, " // &
                            "2x, '!> THLQ(1:" // trim(adjustl(cfmt)) // ")/THIC(1:" // trim(adjustl(cfmt)) // ")/ZPND')"
                    write(ECHO_TXT_IUN, cfmtt) (thlq(i, m, j), j = 1, ignd), (thic(i, m, j), j = 1, ignd), zpnd(i, m)
                    write(ECHO_TXT_IUN, "(6(f10.3), 2x, '!> RCAN/SNCAN/SNO/ALBS/RHOS/GRO')") &
                        rcan(i, m), sncan(i, m), sno(i, m), albs(i, m), rhos(i, m), gro(i, m)
                end do
            end do

        end if

    end if

    !> Print end of run diagnostics and information.

    !> Basin vertical water balance totals.
    call print_message('')
    call print_message('End of run totals')
    call print_message('')
    write(line, FMT_GEN) TOTAL_PRE
    call print_message_detail('Total Precipitation         (mm) =' // trim(line))
    write(line, FMT_GEN) TOTAL_EVAP
    call print_message_detail('Total Evaporation           (mm) =' // trim(line))
    write(line, FMT_GEN) TOTAL_ROF
    call print_message_detail('Total Runoff                (mm) =' // trim(line))
    write(line, FMT_GEN) (STG_FIN - STG_INI), STG_INI, STG_FIN
    call print_message_detail('Storage(Change/Init/Final)  (mm) =' // trim(line))
    call print_message('')
    write(line, FMT_GEN) TOTAL_ROFO
    call print_message_detail('Total Overland flow         (mm) =' // trim(line))
    write(line, FMT_GEN) TOTAL_ROFS
    call print_message_detail('Total Interflow             (mm) =' // trim(line))
    write(line, FMT_GEN) TOTAL_ROFB
    call print_message_detail('Total Baseflow              (mm) =' // trim(line))
    call print_message('')

    !> Normal end of run message.
    call print_message('')
    call print_message('Program has terminated normally.')

    !> Calculate and save program run time (to file only).
    call print_echo_txt('')
    call cpu_time(endprog)
    write(line, FMT_GEN) (endprog - startprog)
    call print_echo_txt('Time = ' // trim(adjustl(line)) // ' seconds.')

    !> Absolute termination point (e.g., for worker nodes).
99  continue

    call program_end()

end program
