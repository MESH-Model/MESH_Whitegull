C    This file is part of WATROUTE.
C
C    WATROUTE is free software: you can redistribute it and/or modify
C    it under the terms of the GNU Lesser General Public License as published by
C    the Free Software Foundation, either version 3 of the License, or
C    (at your option) any later version.
C
C    WATROUTE is distributed in the hope that it will be useful,
C    but WITHOUT ANY WARRANTY; without even the implied warranty of
C    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
C    GNU Lesser General Public License for more details.
C
C    You should have received a copy of the GNU Lesser General Public License
C    along with WATROUTE.  If not, see <http://www.gnu.org/licenses/>.

!***********************************************************************
!       copyright (c) by Nick Kouwen and Dave Watson 2007
!***********************************************************************

      SUBROUTINE read_shed_ef(unitNum,flnNum)

C***********************************************************************
C ****NOTE****This subroutine works but still requires extensive cleaning up
C **** Dave Watson is still working on it
C***********************************************************************!

c~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C ~~~~NOTE:  This s/r was modified to read the gridded parameter file  
C ~~~~as well as the shed file for watroute by NK  Jul. 5/07
c~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C***********************************************************************
C     written Mar/06 by Dave Watson
C     derived from rdshed written by Nick Kouwen
C     This subroutine reads the ensim compatible shd file (r2c format).
C     This file is generated by a separate program called "BASIN" (by Nick Kouwen)
C***********************************************************************!
!
!  ntype    - max number of permeability classes in an element
!  al       - grid length in m.
!  step     - grid length in km but if al<1000, it is equal to 1
!  na       - total # of squares in the watershed including extra one in
!             which water runs. e.g.lake
!  xxx(n)    - the north-south coordinate of the n'th element
!  yyy(n)   - the east-west coordinate of the n'th element
!  order    - coordinate file,highest to lowest element.
!  da(n)    - drainage element (n).
!  ibn(n)   - basin number 1-5
!  irough(n)- over land flow conveyance class 1-5.
!  ichnl(n) - #channels/square class1-59
!  aimp(n)  - q/age impermeable area.from.01 to .9
!  next(n)  - the element number into which the n'th element drains
!  s(i,j)   - contains the order number for each square (used to be 
!             drainage direction)
!           - impevious area should never be 1.0 or 0.0.

!***********************************************************************


      use area_watflood

C//////////////////////////////////////////////
C///////////////////////// 
C// Added by Dave

      USE EF_Module
      implicit none
      TYPE(ShedParam) :: header

C// End Dave addition
C/////////////////////////
C//////////////////////////////////////////////

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
      SAVE

      CHARACTER(128):: qstr
      character(20) :: junk,junk20
      character(1)  :: junk1
      CHARACTER(80) :: comment
      CHARACTER(79) :: hdrcomment(100)
      INTEGER :: chksum(160),thms(25),gr10k(25),saug(25),hmbr(25),
     *     dffn(25),simpson(25),colum(50),canag(25),noire8k(25)
      INTEGER :: chsm,ndam1,iallcnt5,dummy1,ntest,nchr,iallocate,ios,
     *     latdegmin,latminmin,latdegmax,latminmax,londegmin,
     *     lonminmin,londegmax,lonminmax,i,j,n,ii,igridflg,
     *     nrvr1,ntmp,l,newformat
      real*4  :: sumclass,cintv,conv
      INTEGER(kind=2) :: result1,n_hdr_lines,zone
      logical :: exists
      real*4, dimension(:,:),   allocatable :: dummy

!      DATA thms/0,211,176,148,108,70,42,14,11,0,0,0,0,0,0,0,0,0,0,0,0,
!     *          0,0,0,0/
      DATA gr10k/47,161,222,229,189,142,69,39,20,7,3,0,0,0,0,0,0,0,0,0,
     *     0,0,0,0,0/
!      DATA canag/45,155,204,210,172,143,100,48,4,0,0,0,0,0,0,0,0,0,0,0,
!     *            0,0,0,0,0/
!      DATA saug/0,191,216,259,278,297,303,109,58,0,0,0,0,0,0,0,0,0,0,0,
!     *          0,0,0,0,0/
!      DATA hmbr/199,288,619,643,823,726,565,458,305,302,122,0,0,0,0,0,
!     *            0,0,0,0,0,0,0,0,0/
!      DATA dffn/149,498,623,610,431,396,223,73,0,0,0,0,0,0,0,0,0,0,0,0,
!     *            0,0,0,0,0/
!      DATA simpson/0,26,114,336,431,467,451,588,578,440,597,527,410,
!     *             292,203,0,0,0,0,0,0,0,0,0,0/
!      DATA colum/0,1100, 837, 723, 453, 711, 914,1072,1683,1621,1944,
!     *           2102,2528,2385,2175,1834,2049,2384,2611,2936,3165,2987,
!     *           2468,2709,2506,3315,3425,3132,2762,3366,
!     *           3059,2217,2021,1371,1336,1291, 904, 576,1118,1272, 359,
!     *              0,   0,   0,   0,   0,   0,   0,   0,   0/
      DATA noire8k/0,0,82,179,299,213,117,288,263,222,
     *     206,169,129,44,0,0,0,0,0,0,0,0,0,0,0/
      DATA ntest/-10588/qstr/'copyright n.kouwen'/nchr/18/
      DATA iallcnt5/0/

C//////////////////////////////////////////////
C///////////////////////// 
C// Added by Dave

C parameter type definitions
      integer*4 unitNum, flnNum, iStat

C Local variables
      character*1024 line, subString, tmpString
      character*128 keyword, value
      integer lineLen, keyLen, wordCount, attCount
      logical rStat, lineType, foundEndHeader

      character *64 attribName
      integer ai, vi, xi, yi, attLen, error, rank
      real*4 val

C initialize default values
      CALL InitShedParam(header)	

C Set unit and fln number
c	unitNum = 31
c	flnNum = 1

      foundEndHeader = .false.

      print*,'in read_shed_ef with',unitNum,flnNum


C// End Dave addition
C/////////////////////////
C//////////////////////////////////////////////


      IF(.not.ID.GT.1)THEN      !  changed Jul. 12/04  nk
!	else
!     TS: NNOTE=100 -> DEFINED AS A PARAMETER IN AREA10A
!     TS - ALLOCATION OF AREA10A ARRAY (REMAINDER)
         if(iallcnt5.eq.0)then
            allocate(note(nnote),stat=iAllocate)
            if(iAllocate.ne.0) STOP
     *           'Error with allocation of area10a array in sheda'
            iallcnt5=1
         endif
      endif

!     AL MUST BE IN INTEGER KILOMETERS
!     COORDINATES OF THE OUTSIDE ELEMENTS OF THE GRID.
!     ALL THE BASIN DATA IS READ ON FILE 9

c      if(iopt.eq.2)print*,'opening unitnum',unitnum
c	if(iopt.eq.2)print*,'filename =',fln(flnnum)
      print*,'opening unitnum',unitnum
      print*,'filename =',fln(flnnum)

!     basin/bsnm_shd.r2c
      open(unit=unitNum ,file=trim(adjustl(fln(flnNum))) ,
     *  status='old',iostat=ios)
      if(ios.ne.0)then
         print*
         print*,'Problems in file', fln(flnNum)
         write(*,99162)fln(flnNum)
         write(98,99162)fln(flnNum)
99162    format(' Warning: Error opening or reading fln:',a999/
     *  ' Probable cause: missing basin/bsnm_???_par.r2c input file'/
     *  ' OR: in config.sys have you set files=100 & buffers=50?'/
     *  ' OR: wrong number in line 2 of the event file for '/
     *  '     number of events listed in event file ')
         print*,'iostat code =',ios
         STOP 'program aborted in read_shed_ef.for @ 185'
      endif

C//////////////////////////////////////////////
C///////////////////////// 
C// Added by Dave
      line(1:1) = '#'

      do WHILE((.NOT.foundEndHeader) .AND.
     &     ((line(1:1) .eq. '#') .OR.
     &     (line(1:1) .eq. ':') .OR.
     &     (LEN_TRIM(line) .eq. 0))) 	

         read(UNIT=unitNum, FMT='((A))', iostat=ios) line ! read a line
         if(ios .eq. -1)then
            write(6,'((A))') 'ERROR: Premature EndOfFile encountered'
            STOP ' Stopped in read_shed_ef'
         end if

         rStat = Detab(line)    ! replace tabs with spaces
         line = ADJUSTL(line)   ! Get rid of leading white space
         lineLen = LEN_TRIM(line) ! Find the length excluding trailing spaces

         if(line(1:1) .eq. ':')then
            wordCount = SplitLine(line, keyword, subString) ! find the keyword
            rStat = ToLowerCase(keyword)
            KeyLen = LEN_TRIM(keyword)
            
            if(keyword(1:KeyLen) .eq. ':endheader')then
               foundEndHeader = .TRUE.
               
            else
               iStat = ParseShedParam(header,keyword,keyLen,
     &              subString)
               if(iStat .lt. 0) then
                  write(*,'(2(A))') 'ERROR parsing ', fln(flnNum)
                  write(*,'(2(A))') '   in line: ',line			
                  STOP ' Stopped in read_shed_ef'
                  return
               else if(iStat .eq. 0) then
C     write(*,'((A), (A))')  'Unrecognized keyword line: ',
C     & line
               endif
            end if
         end if
      end do
	
      coordsys1=header%r2cp%csp%projection
      datum1=header%r2cp%csp%ellipsoid

!     ugly but effective
      open(unit=99,file='junk',status='unknown')
      write(99,99000)header%r2cp%csp%zone
99000 format(i10)
      rewind 99
      read(99,99001)zone1
99001 format(a10)
      close(unit=99,status='delete')

      xcount = header%r2cp%xCount
      ycount = header%r2cp%yCount
      xorigin = header%r2cp%xOrigin
      yorigin = header%r2cp%yOrigin
      xdelta = header%r2cp%xDelta
      ydelta = header%r2cp%yDelta	

      al = header%nominalGridSize_AL
      cintv = header%contourInterval

      ntype = header%classCount-1
!        every where loops are ntype+1
!        this needs to be changed  fix fix
!	 ntype = header%classCount
!        to reading in the actual # land classes &
!        not no classes -1 for inpervious

      nrvr = header%numRiverClasses

      conv = header%r2cp%unitConv

      na = header%totalNumOfGrids
      naa = header%numGridsInBasin
      nnprint = header%debugGridNo

d      if(iopt.eq.2)then
d        print*,'al,cintv,ntype,nrvr,conv',al,cintv,ntype,nrvr,conv
d        print*,'na,naa,nnprint',na,naa,nnprint
d        print*
d      endif

      astep=al/1000.
      istep=int(astep)
      step2=astep*astep
      if(istep.lt.1)istep=1

c	print*,'in read_shed_ef ',al,astep,istep,step2
c	print*
c	pause


      attCount =header%r2cp%ep%attCount 
      CALL LoadAttributeData(header%r2cp%ep, xCount,
     &     yCount, unitNum)
	

C// End Dave addition
C/////////////////////////
C//////////////////////////////////////////////	


!       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  
!       eventually, imax & jnmax should be replaced everywhere in the code
        
      imax=ycount
      jmax=xcount

!       added ll separation Jul. 27/04  nk
C        if(coordsys1.eq.'LATLONG   ')then !commented out line below added by Dave
      if(IsLatLong(header%r2cp%csp))then
         iymin=int(yorigin*60.0)
         iymax=int((yorigin+ycount*ydelta)*60.0) 
         jxmin=int(xorigin*60.0)  
         jxmax=int((xorigin+xcount*xdelta)*60.0)  
         llflg='y'              ! added Mar. 15/06 nk
         grde=xdelta*60.
         grdn=ydelta*60.  
      else
         jxmin=int(xorigin/1000.)
         jxmax=jxmin+grde*(xcount-1)
         iymin=int(yorigin/1000.)
         iymax=iymin+grdn*(ycount-1)
         grde=xdelta/1000.
         grdn=ydelta/1000.  
         llflg='n'              ! added Mar. 15/06 nk
      endif

      if(calling_program_flg.eq.'snw       ')return
      if(calling_program_flg.eq.'moist     ')return


      nastart=1
      naend=naa
      imin=1
      jmin=1
      ib=imin+1
      it=imax-1

!     rl() and ch_length() are the same thing. ch_length used in bsn

!     rev. 9.3.04  Oct.  24/06  - NK: routing parameters dim to na in rte

!     NOTE:  depending on whether this s/r is for rte or spl, dimension 
!            routing pars differently.  na for rte & nrvr for spl
!            Now we dim all for na for spl & rte so mem is wasted in spl
!            But it is so read_shed_ef is the same for all.
!            Probably not a good idea to change for spl because of opt.

      if(iallcnt5.eq.1)then
         allocate(s(imax,jmax),dummy(imax,jmax),rl(na),
     *    xxx(na),yyy(na),da(na),bnkfll(na),slope(na),elev(na),
     *    ibn(na),sl1(na),sl2(na),irough(na),ichnl(na),next(na),
     *    ireach(na),frac(na),aclass(na,ntype+1),glacier_flag(na),
     *    flz(na),pwr(na),r1n(na),r2n(na),mndr(na),aa2(na),aa3(na),
     *    aa4(na),widep(na),theta(na),kcond(na),
     *    flz2(na),pwr2(na),grid_area(na),
     *    stat=iAllocate)
         if(iAllocate.ne.0) STOP
     *        'Error with allocation of area16a arrays in sheda'
!              glacier_flag(na)      added Mar, 28/06  nk
         iallcnt5=2
      endif



C//////////////////////////////////////////////
C///////////////////////// 
C// Added by Dave	


C// First find and copy rank attribute first data over to global array
      if(unitnum.eq.31)then
!       for the shed file:
         do ai=1,attCount-(ntype+1)             
            vi = 0
            attribName = header%r2cp%ep%attList(ai)%name
            rStat = ToLowerCase(attribName)
            attLen = LEN_TRIM(attribName)
            if(attribName(1:attLen) .eq. 'rank')then 
               do yi=1,yCount
                  do xi=1,xCount
                     vi = vi+1
                     val = header%r2cp%ep%attList(ai)%val(vi)
                     s(yi,xi) = val
                  end do
               end do
            end if
         end do
      else
!       for the par file:
         do ai=1,attCount             
            vi = 0
            attribName = header%r2cp%ep%attList(ai)%name
            rStat = ToLowerCase(attribName)
            attLen = LEN_TRIM(attribName)
            if(attribName(1:attLen) .eq. 'rank')then 
               do yi=1,yCount
                  do xi=1,xCount
                     vi = vi+1
                     val = header%r2cp%ep%attList(ai)%val(vi)
                     s(yi,xi) = val
                  end do
               end do
            end if
         end do
      endif

C// Copy attribute data (not classes yet) over to global attributes
      vi = 0
      do yi=1,yCount
         do xi=1,xCount
            vi = vi+1
            rank = s(yi,xi)
            if(rank.gt.0) then
               do ai=1,attCount
                  ! Read attributes from the r2c file and store them
                  ! in our internal arrays.  Slope, sl1, and elev get
                  ! some additional processing
                  attribName = header%r2cp%ep%attList(ai)%name
                  rStat = ToLowerCase(attribName)
                  attLen = LEN_TRIM(attribName)
                  val = header%r2cp%ep%attList(ai)%val(vi)
                  if(attribName(1:attLen) .eq. 'next')then
                     next(rank) = int(val)
                  else if(attribName(1:attLen) .eq. 'da')then
                     da(rank) = val
                  else if(attribName(1:attLen).eq.'bankfull')then
                     bnkfll(rank) = val
                  else if(attribName(1:attLen).eq.'chnlslope')then
                     ! Christopher Subich; Sept 12
                     ! The square root of slope is used in the flow
                     ! calculations, so take that here (and perform
                     ! a sanity-check for negative values). Previously,
                     ! this was done as a post-processing step, leading
                     ! to a bug reported by Frank Seglenieks that the
                     ! square-root was being done twice when this
                     ! procedure was called a second time to read the
                     ! *_par.r2c file.
                     if (val .lt. 0.0) then
                        ! Unfortunately the indentation here is poor
                        ! because of the 72-column limit for a fixed-
                        ! format source
                        print*,
     *                  'In read_shed_ef reading the file :',fln(flnNum)
                        print*,
     *                  'The slope in grid no ',rank,' is ',slope(rank)
                        print*,
     *                  'Please check the elevations in the map file '
                        print*,
     *                  'or change the slope value in the shd file'
                        print*,
     *             'The former is recommended as the permanent solution'
                        print*
                        stop 'Program aborted in read_shed_ef @ 447'
                     endif
                     slope(rank) = sqrt(val)
                  else if(attribName(1:attLen) .eq. 'elev')then
                     ! Elevation is re-scaled
                     elev(rank) = 0.01*val
                  else if(attribName(1:attLen) .eq. 'chnllength')then
                     rl(rank) = val
                  else if(attribName(1:attLen) .eq. 'iak')then
                     ibn(rank) = val
                  else if(attribName(1:attLen) .eq. 'intslope')then 
                     if (val .lt. 0) then
                        print *, 'Negative intslope received of', val
                        print *, 'at grid number ', n, 'in the shd file'
                        stop 'Program aborted in read_shed_ef @ 461'
                     end if
                     ! used for overland flow routing (runof6)
                     sl1(rank) = val
                     ! set sl2 as square root of sl1
                     sl2(rank) = sqrt(val)
                  else if(attribName(1:attLen) .eq. 'chnl')then
                     ichnl(rank) = val
                  else if(attribName(1:attLen) .eq. 'reach')then
                     ireach(rank) = val

!      WATROUTE attributes added by nk  Oct. 1/06

                  else if(attribName(1:attLen) .eq. 'flz')then
                     flz(rank) = val
                  else if(attribName(1:attLen) .eq. 'pwr')then
                     pwr(rank) = val
                  else if(attribName(1:attLen) .eq. 'r1n')then
                     r1n(rank) = val
                  else if(attribName(1:attLen) .eq. 'r2n')then
                     r2n(rank) = val
                  else if(attribName(1:attLen) .eq. 'mndr')then
                     mndr(rank) = val
                  else if(attribName(1:attLen) .eq. 'aa2')then
                     aa2(rank) = val
                  else if(attribName(1:attLen) .eq. 'aa3')then
                     aa3(rank) = val
                  else if(attribName(1:attLen) .eq. 'aa4')then
                     aa4(rank) = val
                  else if(attribName(1:attLen) .eq. 'theta')then
                     theta(rank) = val
                  else if(attribName(1:attLen) .eq. 'widep')then
                     widep(rank) = val
                  else if(attribName(1:attLen) .eq. 'kcond')then
                     kcond(rank) = val
!      end attributed added by nk

                  else if(attribName(1:attLen) .eq. 'gridarea')then
                     grid_area(rank) = val
                     frac(rank)=grid_area(rank)/al/al
!       frac is still used in the code but no longer in the shed file   
                  else if(attribName(1:attLen) .eq. 'frac')then
!				frac(rank) = val
                     print*
                     print*,'Error: old format shd file found'
               print*,'Please create a new bsnm_shd.r2c file using the'
                     print*,'current version of bsn.exe'
                     print*
                     stop 'Program aborted in read_shed_ef.for @ 507'
!      impervious area no longer used  nk
c   		  	  else if(attribName(1:attLen) .eq. 'imperv')then
c                              aclass(rank, ntype+1) = val
!      end no longer used

                  end if
               end do
            endif
         end do
      end do



      manningflg='y'

C// Copy class attribute data over to global attributes
      if(unitnum.eq.31)then
         vi = 0
         do yi=1,yCount
            do xi=1,xCount
               vi = vi+1
               rank = s(yi,xi)
               if(rank.gt.0) then
                  do ai=attCount-ntype,attCount  
                     val = header%r2cp%ep%attList(ai)%val(vi)
                     aclass(rank,ai-(attCount-(ntype+1))) = val
!		aclass(rank,ai-(attCount-ntype)) = val
                  enddo
               endif
            end do
         end do
      endif


!     pick the dominant class in this grid for debug printing
      iiprint=1
      do ii=2,ntype+1
         if(aclass(nnprint,ii).gt.aclass(nnprint,iiprint))iiprint=ii
      end do
        
C// Copy rows and col over to global attributes
C// I'm not sure if we need this...check with Nick
! csubich -- yes, because these arrays are used in sanity-check
! code later to see if a given rank is actually present on the
! grid
      vi = 0
      do yi=1,yCount
         do xi=1,xCount
            vi = vi+1
            rank = s(yi,xi)
            if(rank.gt.0) then
               xxx(rank) = xi
               yyy(rank) = yi
            endif
         end do
      end do

      do i=1,ycount
         do j=1,xcount
            dummy(i,j)=0.0
         end do
      end do


!     Write the land cover class fractions to spl.txt
      if(iopt.ge.1)then
         write(51,50002)
         do ii=1,ntype+1
            write(51,50001)ii
            do i=1,ycount
               do j=1,xcount
                  n=s(i,j)
                  if(n.gt.0)dummy(i,j)=aclass(n,ii) 
               end do
               write(51,50000)(dummy(i,j),j=1,xcount)
         end do
         end do
      endif
50000 format(999f6.2)
50001 format('class no=',i5)
50002 format('Land Cover class fractions:')

 
C// Deallocate the attribute data now that global attributes have been set
      do ai=1,attCount
         deallocate ( header%r2cp%ep%attList(ai)%val, STAT = error )
         if (error.ne.0) STOP 'deallocation error in read_gsm_ef()' 
      end do

C Debug check for Dave
C	do n=1,na
C		write(6,6004)n,next(n),yyy(n),xxx(n),da(n),bnkfll(n),
C     *	slope(n),elev(n),rl(n), ibn(n),sl1(n),
C     *	ichnl(n),ireach(n),frac(n),
C     *	(aclass(n,ii),ii=1,ntype+1)
C	      write(6,*)
C	end do
C      pause 'in read_shed_ef  @  538'



C// End Dave addition
C/////////////////////////
C//////////////////////////////////////////////


!     GRAND RIVER:
      if(iymin.eq.4790.and.jxmin.eq.500)then
         do i=1,25
            chksum(i)=gr10k(i)
         end do
      end if


      ichsm=1     
!     if one is no good, kill run
      do i=1,min(25,imax)
         chsm=0
         do j=jmin,jmax
            chsm=chsm+s(i,j)
         end do
!       print*,' i,shksun(i),chsm /',i,chksum(i),chsm
         if(chsm.ne.chksum(i))then
            ichsm=0             ! program will abort
         end if
      end do

!	close this loophole - Oct. 15/03 NK
!     when the top left hand corner of the grid are all zeros
!     the checksums are all zero and the program would run.
      chsm=0
      do i=1,min(25,imax)
         do j=jmin,jmax
            chsm=chsm+s(i,j)
         end do
      end do
      if(chsm.eq.0)then
         ichsm=0                ! program will abort
      end if


c!     South Nation
c      if(xcount.eq.75.and.ycount.eq.44.and.na.eq.1634.and.naa.eq.1631)
c     *then
c!	  ichsm=1
c	else
c!	  ichsm=0        ! program will abort
c	endif
      




!     rev. 9.1.46  Jul.  17/03  - WATFLOOD LITE incorporated 
!     WATFLOOD LT
!     WATFLOOD LT
      if(imax.le.7.and.jmax.le.7.and.na.le.15.and.al.le.1000.0)then
!       when ever these conditions are met, the program will run
!       Since the gr10k files exceed these bounds, the messages will
!       appropriate.
         ichsm=3
      endif
!     WATFLOOD LT
!     WATFLOOD LT

      if(nnprint.gt.naa)then
         nnprint=naa/2
         ipr=yyy(nnprint)       ! probably not needed anywhere
         jpr=xxx(nnprint)
      else
!       this can happen when a sub-watershed is used
!       for new format
         ipr=yyy(nnprint)       ! probably not needed anywhere
         jpr=xxx(nnprint)
      endif
      write(51,*)
      write(51,5000)nnprint,ipr,jpr


!     REV. 8.92 - Dec.  24/89 -  CHECK FOR 100% ACLASS COVERAGE
      igridflg=0
      do n=1,naa
         sumclass=0.0
         do ii=1,ntype+1
            sumclass=sumclass+aclass(n,ii)
         end do
         if(sumclass.ne.1.0)then
            igridflg=1
            write(98,9023)n,yyy(n),xxx(n),sumclass
            do ii=1,ntype+1
               if(sumclass.gt.0.0)then
                  aclass(n,ii)=aclass(n,ii)/sumclass
               else
                  write(98,9024)n,yyy(n),xxx(n)
               endif
            end do
         end if
      end do

!     FOR SPLD ONLY:
!     * * * * * * * * * * * * * * * * *
!     include 'demosize.for'

!     Checking data:

!    check to see how many basins/river classes there are:
      nrvr1 = maxval(ibn) ! use array syntax

c      if( nrvr.ne.nrvr1)then
c!      if(nrvr.lt.nrvr1)then
c        print*,'no of river classes specifies in .shd header =',nrvr
c        print*,'no found in .shd grid data =',nrvr1
c        print*,'the header should = no found in gridded data'
c        print*,'the no in the header should be ',nrvr1 
c        print*,'Ignore this warning if you are running a sub-watershed'
c        pause ' program paused in rd_shed_ef'
c      endif
c
c      nrvr=nrvr1
c      print*,'nrvr=',nrvr
c      print*
c      pause 'in read_shed_ef'
c
c          
c      if(nrvr.le.0.or.nrvr.gt.16)then
c        print*,' In the .shd file: ',fln(flnNum)
c        print*,' Column 16-20 should have the value for nrvr'
c        print*,' the number of river classes '
c        print*,' It must have a value 1-16'
c        print*,' The number of river/basin types should match'
c        print*,' in the .par and .shd files'
c        print*,' Please enter the correct number in the'
c        print*,' .par and .shd files. To get the correct number,'
c        print*,' create a new .shd file using bsn.exe and then match'
c        print*,' it in the .par file - making sure there are an '
c        print*,' equal number of parameter sets for rivers'
c        print*
c        stop ' Program aborted in rdshd @ 729'
c      endif


c!     check ntypeo and nbsn:
c      if(ntypeo.gt.ntype)then
c        print*,' number of landcovers to be optimized greater than'
c        print*,' number of landcover classes in the .shd file'
c        print*
c        stop 'Program aborted in shed @ 236'
c      endif
c      if(nbsn.gt.nrvr)then
c        print*,' nbsn=',nbsn,' nrvr=',nrvr
c        print*,' number of river types to be optimized greater'
c        print*,' number of river classes found in the .shd file'
c        print*
c        stop 'Program aborted in shed @ 242'
c      endif



      close(unit=unitNum)
!     WE WILL USE THIS UNIT NUMBER AGAIN FOR THE DAMAGE SITE FILE

      write(51,6006)
      write(51,6007)

      write(51,*)' Note: order not the same as the .shd file YET'

c         if(ntype.le.0)then
c            do n=1,naa
c               write(51,6004)n,yyy(n),xxx(n),da(n),bnkfll(n),
c     *         slope(n)**2,
c     *         elev(n),ibn(n),sl2(n),ichnl(n),next(n),ireach(n),frac(n),
c     *	       (aclass(n,ii),ii=1,ntype)
c            end do
c         else
c            do n=1,naa
c               write(51,6004)n,yyy(n),xxx(n),da(n),bnkfll(n),
c     *         slope(n)**2,elev(n),ibn(n),sl1(n),
c     *         ichnl(n),next(n),ireach(n),frac(n),aclass(n,ntype+1),
c     *         (aclass(n,ii),ii=1,ntype)
c            end do
c         endif
!      endif


c!     WRITE THE MAP INFORMATION TO THE /SPL/SIMOUT/PIC.LST FILE:
c      write(56,9005)na,jmax,imax
c      do n=1,na
c         write(56,9005)n,yyy(n),xxx(n),next(n)
c      end do


!     TS - ALLOCATIONS OF AREA4A ARRAYS
!     ntype for the number of land cover classes
!     nrivertype for the number of channel or basin types
!     moved here from spl9  nk 06/07/00
!     then moved from rdpar nk 28/12/04
!     parameter allocation moved to rdpar  27/07/06 nk  - needed by bsn
!     no good. Moved back here. fix bsn some other way

!     needed for rdpar

c      allocate(mndr(nrvr),
c     *r1(nrvr),r2(nrvr),r2low(nrvr),r2hgh(nrvr),r2dlt(nrvr),
c     *aa2(nrvr),aa3(nrvr),aa4(nrvr),rivtype(nrvr),
c     *theta(nrvr),thetadlt(nrvr),thetalow(nrvr),thetahgh(nrvr),
c     *widep(nrvr),widepdlt(nrvr),wideplow(nrvr),widephgh(nrvr),
c     *kcond(nrvr),kconddlt(nrvr),kcondlow(nrvr),kcondhgh(nrvr),
c     *flz(nrvr),flz2(nrvr),flzlow(nrvr),flzhgh(nrvr),flzdlt(nrvr),
c     *pwr(nrvr),pwr2(nrvr),pwrlow(nrvr),pwrhgh(nrvr),pwrdlt(nrvr),
c     *stat=iAllocate)
c      if(iAllocate.ne.0) STOP
c     *   'Error with allocation of area4a arrays in rdpar'


c      print*,'nrvr==',nrvr
c      print*,'nrvr==',nrvr,mndr(nrvr)
c      print*,'nrvr==',nrvr,mndr(nrvr),r1n(nrvr)
c      print*,'nrvr==',nrvr,mndr(nrvr),r1n(nrvr),r2n(nrvr)
c      print*
c      pause 'mmmmmmmmmmm'

c      allocate(
c     *mndr(nrvr),r1n(nrvr),r2n(nrvr),
c     *aa2(nrvr),aa3(nrvr),aa4(nrvr),rivtype(nrvr),
c     *theta(nrvr),widep(nrvr),kcond(nrvr),
c     *flz(nrvr),pwr(nrvr),
c     *stat=iAllocate)
c      if(iAllocate.ne.0) STOP
c     *   'Error with allocation of area4a arrays in read_shed_ef'



C     some of these are now allocated above for na instead of nrvr
c        for watroute because included in the shed file

c      allocate(mndr(nrvr),r1n(nrvr),r2n(nrvr),
c     *aa2(nrvr),aa3(nrvr),aa4(nrvr),rivtype(nrvr),
c     *theta(nrvr),widep(nrvr),kcond(nrvr),
c     *flz(nrvr),pwr(nrvr),
c     *stat=iAllocate)
c      if(iAllocate.ne.0) STOP
c     *   'Error with allocation of area4 arrays in read_shed_ef'


c!     these are not needed for watroute 
c      if(.NOT.allocated(rivtype))then
c        allocate(rivtype(nrvr),stat=iAllocate)
c        if(iAllocate.ne.0) STOP
c     *   'Error with allocation of area4 arrays in read_shed_ef'
c      endif


! * * * *  TS  * * * * *
!     TS - ALLOCATIONS OF AREAWET ARRAYS
      if(.NOT.allocated(wetwid))then
      allocate(wetwid(na),chawid(na),chadep(na),wstore1(na),wstore2(na),
     *  wcap(na),flowxa(na),chaxa(na),satxa(na),wetxa(na),hcha1(na),
     *  hcha2(na),hwet1(na),hwet2(na),qin(na),qswevp(na),
     *  qswrain(na),qiwet1(na),qiwet2(na),qowet1(na),qowet2(na),
     *  wetarea(na),chaarea(na),bin_precip(na),wsat(na),wetfrac(na),
     *  stat=iAllocate)
      if(iAllocate.ne.0) STOP
     *     'Warning: error with allocation of areaswmp in read_shed_ef'
      endif
! * * * * * * * * * * *



!     TS - ALLOCATIONS OF AREA1A ARRAYS

!     *xxx(na),yyy(na),da(na),bnkfll(na),slope(na),elev(na),
!     *ibn(na),irough(na),ichnl(na),next(na),ireach(na),frac(na),
!     *aclass(na,ntype+1),ch_length(na),sl1(na),rl(na),
!     *pot(ntype+1),potfs(ntype+1),qlz(na),psmear(na),punused(na),
      if(.NOT.allocated(qi1))then
        allocate(qi1(na),qi2(na),qo1(na),qo2(na),qo2sim(na),qr(na),
     *  d2(na),qda(na),cap(na),over(na),
     *  qmax(na),res(na),qo2rem(na),
     *  sump(na),store1(na),store2(na),att(na),
     *  qbase(na),nreach(30), 
     *  rf(na,ntype+1),rffs(na,ntype+1),
     *  r(na,ntype+1),effpor(na,ntype+1),
     *  v(na,ntype+1),totd1(na),totuzs(na),totsnw(na),qstream(na),
     *  totchnl(na),totgrid(na),netflow(na),storinit(na),d1(na,ntype+1),
     *  d1fs(na,ntype+1),uzs(na,ntype+1),uzsfs(na,ntype+1),lzs(na),
     *  sumf(na,ntype+1),sumrechrg(na),
     *  sumffs(na,ntype+1),snow(na,ntype+1),sumrff(na),rechrg(na),
!     *pot(ntype+1),potfs(ntype+1),    moved to rrpar  nk  May 15/07
     *  qlz(na),sr(ntype+1),x4(ntype+1),x5(ntype+1),q1(na,ntype+1),
     *  q1fs(na,ntype+1),qint(na,ntype+1),qintfs(na,ntype+1),
     *  fake(ntype+1),fakefs(ntype+1),
     *  qdrng(na),qdrngfs(na),
     *  drng(na,ntype+1),drngfs(na,ntype+1),sq1(ntype+1),
     *  sq1fs(ntype+1),sqint(ntype+1),sqintfs(ntype+1),sdrng(ntype+1),
     *  sdrngfs(ntype+1),sexcess(ntype+1),qstrm(na),
     *  sumq1(na),sumqint(na),sumq1fs(na),sumqintfs(na),
     *  stat=iAllocate)
        if(iAllocate.ne.0) STOP
     *   'Warning: error with allocation of area1 in read_shed_ef'
      endif

!     TS - ALLOCATIONS OF AREAETA ARRAYS (PARTIAL)
!     RAD ALLOCATED IN SHEDA.FOR
!     rev. 9.1.80  Mar.  31/05  - NK: added sublimation   (sublim)
      if(.NOT.allocated(strloss))then
         allocate(strloss(na),stat=iAllocate)
         if(iAllocate.ne.0) STOP
     *     'Warning: error with allocation of areaeta arrays in spl9'
      endif

!     OCT30/03 TS:  ADDED SUMQI,SUMQINT,SUMQ1FS AND SUMQINTFS ALLOCATIONS


!     JUN28/06 TS: ADDED DF, DFFS FOR ISOTOPE ROUTINES
      if(.NOT.allocated(df))then
         allocate(df(na,ntype+1),dffs(na,ntype+1),
     *        qdrng2(na),qdrngfs2(na),
     *        stat=iAllocate)
         if(iAllocate.ne.0) STOP
     *        'Warning: error with allocation of areaeta arrays in spl9'
      endif



!     TS - ALLOCATIONS OF AREA4A ARRAYS
!     ntype for the number of land cover classes
!     nbsn for the number of channel or basin types
C      allocate(
C     *ds(ntype),dsfs(ntype),chnl(ntype),
C     *r3(ntype),r4(ntype),r3fs(ntype),rec(ntype),ak(ntype),akfs(ntype),
C     *r3low(ntype),r3fslow(ntype),reclow(ntype),
C     *aklow(ntype),akfslow(ntype),ak2fslow(ntype),
C     *r3hgh(ntype),r3fshgh(ntype),rechgh(ntype),akhgh(ntype),
C     *akfshgh(ntype),ak2fshgh(ntype),r3dlt(ntype),
C     *r3fsdlt(ntype),recdlt(ntype),akdlt(ntype),akfsdlt(ntype),
C     *ak2fsdlt(ntype),retn(ntype),ak2(ntype),
C     *retnlow(ntype),ak2low(ntype),
C     *retnhgh(ntype),ak2hgh(ntype),
C     *retndlt(ntype),ak2dlt(ntype),
C     *retfs(ntype),ak2fs(ntype),fpet(ntype),
C     *fpetdlt(ntype),fpetlow(ntype),fpethgh(ntype),ftall(ntype),
C     *ftalldlt(ntype),ftalllow(ntype),ftallhgh(ntype),nclass(ntype+1),
C     *iiclass(ntype*2),h(12,ntype),fpetmo(12,ntype),stat=iAllocate)
C      if(iAllocate.ne.0) STOP
C     *   'Warning: error with allocation of area4a arrays in spl9'



c!     TS - ALLOCATIONS OF AREAETA ARRAYS (PARTIAL)
c!     RAD ALLOCATED IN SHEDA.FOR
c!     rev. 9.1.80  Mar.  31/05  - NK: added sublimation   (sublim)
c      allocate(vo(na,ntype),intev(na,ntype+1),
c     *sublim(na,ntype+1),sum_sublim(na,ntype+1),
c     *sum_et(na,ntype+1),sum_pet(na,ntype+1),
c     *ev(na,ntype+1),pet(na,ntype+1),fpet2(na),
c     *x2(na,ntype),x3(na,ntype),intevt(na,ntype+1),
c     *evt(na,ntype+1),ssumr(na,ntype+1),totint(na),eloss(na),
c     *strloss(na),
c     *uzsinit(ntype+1),v1(na,ntype),radv(na),
c     *flgtemp(na),tto(na),ttomin(na),ttomax(na),ice_factor(na),
c     *evcg(na,ntype+1),acg(ntype+1),bcg(ntype+1),
c     *stat=iAllocate)
c !    *rh(na),stat=iAllocate)
c      if(iAllocate.ne.0) STOP
c     *   'Warning: error with allocation of areaeta arrays in spl9'


! AB Added to make sure that intevt(n,ii)=intevt(n,ii)+intev(n,ii) in intcept works May 10, 2002
c	do i=1,na
c	  do j=1,ntype+1
c	    intevt(i,j)=0
c	  enddo
c	enddo

!     TS - ALLOCATIONS OF AREAMELTA ARRAYS (PARTIAL)
!     SNW,DSN,TTEMP,TMX,TMN,EL ALLOCATED IN SHEDA.FOR
!     SDCD,SDCSCA ALLOCATED IN RDSDCA.FOR
c      allocate(snowc(na,ntype+1),dsnow(na),
c     *tmax(na),tmin(na),
c     *tmin1(na),tmin2(na),sca(na,ntype+1),oldsca(na,ntype+1),
c     *fexcess(na,ntype+1),snowcmin(na,ntype+1),wcl(na,ntype+1),
c     *nsdc(ntype+1),
c     *snocap(ntype+1),
c     *ati(na,ntype+1),def(na,ntype+1),
c     *qtot(ntype+1),robg(ntype+1),rosn(ntype+1),qnet(ntype+1),
c     *smelt(ntype+1),excess(ntype+1),extra(ntype+1),idump(ntype+1),
c     *qrain(ntype+1),qsnow(ntype+1),qrn(na),qsn(na),glmelt(na),
c     *qe(ntype+1),qh(ntype+1),qn(ntype+1),qp(ntype+1),refrz(ntype+1),
c     *fmadj(na),stat=iAllocate)
c      if(iAllocate.ne.0) STOP
c     *   'Warning: error with allocation of areamelta arrays in spl9'

! AB Added to make sure that min(tempv(n),tempvmin(n)) in rdtemp works May 10, 2002
c      do n=1,na
c!	  tempvmin(n)=99.99
c        do ii=1,ntype+1
c          wcl(n,ii)=0.0
c        end do
c	enddo

c!     TS - ALLOCATIONS OF AREAOPTSA ARRAYS
c      allocate(fmdlt(ntype),fmlow(ntype),fmhgh(ntype),fmndlt(ntype),
c     *fmnlow(ntype),fmnhgh(ntype),uajdlt(ntype),uajlow(ntype),
c     *uajhgh(ntype),mbsdlt(ntype),mbslow(ntype),mbshgh(ntype),
c     *basdlt(ntype),baslow(ntype),bashgh(ntype),stat=iAllocate)
c      if(iAllocate.ne.0) STOP
c     *   'Warning: error with allocation of areaoptsa arrays in spl9'



c      if(newevtflg.eq.'y')then
c!       section added for new .pdl file   NK 04/10/04
c
c
c        INQUIRE(FILE=fln(3),EXIST=exists)
c        IF(exists)THEN
c
c          open(unit=33,file=fln(3),status='old',iostat=ios)
c	    if(ios.ne.0)then
c	      print*,'Problems opening .pdl file ',fln(3)
c	      print*
c            stop 'Program aborted in shed @ 903'
c	    endif
c          junk='                    '
c	    do while(junk.ne.':NoDamageSites      ')
c            read(33,*,iostat=ios)junk
c            if(ios.ne.0)then
c              print*,'last line read in the .pdl file ='
c              print*,junk
c              print*,' \ios =',ios
c              ndam=0
c              return        ! >>>>>>>>>>>>>>>>>>>>>>>>
c            endif            
c          end do
c          backspace(33)
c          read(33,*)junk,ndam
c
c          if(ndam.eq.0)return     ! >>>>>>>>>>>>>>>>>>
c
c
c          read(33,*)junk       !    #
c!         NOW WE GET TO THE DAMAGE LOCATIONS:
c!         IN OLD FILES, NO DAMAGE LOCATIONS WERE SPECIFIED 
c!         SO THE NO. OF DAMAGE SITES IS SET TO 0 - NO PROBLEM
c
c          if(.not.id.gt.1)THEN
c            ndam1=max(1,ndam)
c!           can not allocate 0,nnnn - I guess NK  16/08/00
c!           TS - ALLOCATION OF AREA10A ARRAYS (REMAINDER)
c            if(iallcnt5.eq.2)then
c!               these will replace iys & jxs respectively
c             allocate(xdamg_locn(ndam1),ydamg_locn(ndam1),
c     *         iys(ndam1),jxs(ndam1),datum(ndam1),frcs(ndam1,41),
c     *         damage(ndam1),qloc(ndam1,8784),stat=iAllocate)
c             if(iAllocate.ne.0) STOP
c     *         'Error with allocation of area10a arrays in sheda'
c             iallcnt5=3
c	      endif
c	    ENDIF
c
c          do l=1,ndam
c            read(33,*,iostat=ios)xdamg_locn(l),ydamg_locn(l),
c     *                      damage(l),(frcs(l,i),i=1,4),datum(l)
c            if(ios.ne.0)then
c              print*,'problems reading damage location =',ndam
c            endif
c
c!         need fix fix for ll also
c            jxs(l)=int(xdamg_locn(l)/1000.)
c            iys(l)=int(ydamg_locn(l)/1000.)
c
c            iys(l)=(iys(l)-iymin)/istep+1
c            jxs(l)=(jxs(l)-jxmin)/istep+1
c
c!           DAMAGE LOCATIONS ARE NOW CONVERTED TO COMPUTATION
c!           GRID COORDINATES
c            write(53,1102)iys(l),jxs(l),damage(l),(frcs(l,i),i=1,4),
c     *                 datum(l)
c          end do
c
c          read(33,*)junk       !    #
c
c          do i=1,nnote
c            read(33,1098,end=480)note(i)
c!           write(*,1098)note(i)
c          end do
c  480     CONTINUE
c!         redefine the size of the array for later printing:
c          nnnote=i-1
c          write(53,1098)(note(i),i=1,nnnote)
c          close(unit=33)
c        endif      ! if fln(3) exists
c!       fix fix section above for new coordinate formats utm & ll
c
c	else
c!       old format file
c!       READ THE DAMAGE SITE LOCATIONS FROM THE BASIN/XXXX.STR FILE:
c
c
c        INQUIRE(FILE=fln(4),EXIST=exists)
c        IF(exists)THEN
c
c          open(unit=34,file=fln(4),status='old',err=99901)
c          if(ios.ne.0)then
c      print*,'Problems reading basin\bsnm.str file'
c      print*,'Expected file name =',fln(4)
c      print*
c           stop 'Program terminated in read_shed_ef @ 899'
c    endif
c
c
c         read (34,1000,err=99910)ntmp
c         do n=1,ntmp
c            read (34,*,err=99910)
c         end do
c
c         THIS FILE ALSO HAS THE RESERVOIR LOCATION COORDINATES
c         read (34,6014,end=9998)ntmp
c
c         if(ntmp.gt.0)then
c           do n=1,ntmp
c              read (34,*,end=9998)
c           end do
c         endif
c
c         THIS FILE ALSO HAS THE RESERVOIR LOCATION COORDINATES
c
c         NOW WE GET TO THE DAMAGE LOCATIONS:
c         IN OLD FILES, NO DAMAGE LOCATIONS WERE SPECIFIED 
c         SO THE NO. OF DAMAGE SITES IS SET TO 0 - NO PROBLEM
c
c         read(34,1000,end=9999)ndam
c
c
c         if(id.gt.1)THEN
c           dummy
c    ELSE
c           ndam1=max(1,ndam)
c           can not allocate 0,nnnn - I guess NK  16/08/00
c           TS - ALLOCATION OF AREA10A ARRAYS (REMAINDER)
c           if(iallcnt5.eq.2)then
c            allocate(iys(ndam1),jxs(ndam1),datum(ndam1),frcs(ndam1,41),
c    *         damage(ndam1),qloc(ndam1,8784),stat=iAllocate)
c            if(iAllocate.ne.0) STOP
c    *         'Error with allocation of area10a arrays in sheda'
c            iallcnt5=3
c      endif
c    ENDIF
c
c         do l=1,ndam
c           read(34,1099,end=9999)iys(l),jxs(l),damage(l),
c    *                           (frcs(l,i),i=1,4),datum(l)
c
c           iys(l)=(iys(l)-iymin)/istep+1
c           jxs(l)=(jxs(l)-jxmin)/istep+1
c
c           DAMAGE LOCATIONS ARE NOW CONVERTED TO COMPUTATION
c           GRID COORDINATES
c           write(53,1102)iys(l),jxs(l),damage(l),(frcs(l,i),i=1,4),
c    *                 datum(l)
c         end do
c 
c         do i=1,nnote
c           read(34,1098,end=490)note(i)
c           write(*,1098)note(i)
c         end do
c 490     CONTINUE
c         redefine the size of the array for later printing:
c         nnnote=i-1
c         write(53,1098)(note(i),i=1,nnnote)
c         close(unit=34)
c       endif    !  if fln(4) exists
c     endif

      return
      

 9998 ntmp=0
      ndam=0
      write(98,9025)
      write(98,9026)
      close(unit=34)
      RETURN

 9999 ndam=0
      write(98,9026)
      close(unit=34)
      RETURN

99901 write(*,99902)fln(4)
99902 format(' file',a999,' not found for unit 34 - check event file')
      STOP 'program stopped in shed.for at 99902'

99910 write(*,99911)fln(4)
99911 format(' no data found or problems with data in ',a999)
      STOP 'program stopped in shed at 99911'

! FORMATS

 1000 format(i5)
 1002 format(' ',i5,'stream gage locations have been passed over')
 1003 format(' ',i5,'reservoir locations have been passed over')
 1004 format(' ',i5,'damage sites:')
 1098 format(a999)
 1099 format(2i5,1x,a12,7x,4e10.3,f10.3)
 1100 format(' ',2i5,1x,a12,7x,4e10.3,f10.3)
 1101 format(' reading the stream gauge location file: ',a999)
 1102 format(' ',2i5,1x,a12,7x,4e10.3,f10.3/)
 1776 format(' ','l,iys(l),jxs(l)',5i5)
        write(51,*)

 5000 format(' Debug grid reset to grid number n,row col',3i7)
  
 6004 format(1x,4i4,f7.1,f7.2,f8.4,2f7.0,i3,f7.4,2i3,7f5.2)
 6006 format(2x,'basin file:')
 6007 format(4x,'n   yy   xx      da       cap       slope    elv',
     *'     ibn   sl2    ich  next reach frac  imp area & fractions')
 6014 format(i5)
  
 9005 format(12i5,2f5.0)

 9023 format(' Warning: area correction in grid(n,i,j)',3i5,f9.5)
 9024 format(' Warning: total area = 0.0 for grid(n,i,j)',3i5)
 9025 format(' Warning: no reservoirs or lakes in bsnm.str file')
 9026 format(' Warning: no damage sites in bsnm.str file')

      RETURN

      END SUBROUTINE read_shed_ef

